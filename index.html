<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Lexica Realms - MVP</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' ry='12' fill='%23ffffff'/%3E%3Ctext x='50%25' y='54%25' dominant-baseline='middle' text-anchor='middle' font-size='44'%3Eüî§%3C/text%3E%3C/svg%3E">
<style>
  :root{
    --blue:#77b7ff; --lilac:#c3a5ff; --shadow: rgba(0,0,0,0.12); --ink:#111;
    --img-breaker: "";   /* url(sprites/hammer.png) */
    --img-row: "";       /* url(sprites/row_breaker.png) */
    --img-col: "";       /* url(sprites/column_breaker.png) */
    --img-rainbow: "";   /* url(sprites/wildcard.png) */
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent;touch-action:none;}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    background:linear-gradient(180deg,#f6fbff,#f9f9ff);
    color:var(--ink);
    padding-top: env(safe-area-inset-top); padding-bottom: env(safe-area-inset-bottom);
  }
  #app{width:100vw;height:calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));max-width:480px;margin:0 auto;display:flex;flex-direction:column;}

  header{
    width:100%; padding:10px 16px; display:flex; justify-content:space-between; align-items:center;
    background:#e9eaed; border-bottom-left-radius:22px; border-bottom-right-radius:22px;
    box-shadow:0 2px 10px var(--shadow); position:sticky; top:0; z-index:5;
  }
  .debug-badge{background:#ff8f2e;color:#fff;font-weight:900;border:none;border-radius:10px;padding:8px 12px;box-shadow:0 2px 6px var(--shadow);} 
  .goals-bar{display:flex;align-items:center;gap:18px;background:#a87657;color:#2b1b12;padding:10px 16px;border-radius:16px;margin-left:10px;}
  .goal-item{display:flex;flex-direction:column;align-items:center;gap:6px;}
  .goal-swatch{width:34px;height:34px;border-radius:6px;box-shadow:inset 0 2px 0 rgba(255,255,255,.5), inset 0 -2px 0 rgba(0,0,0,.15);}
  .goal-num{font-weight:900;}
  .stat{display:flex;gap:10px;align-items:center;font-weight:700;}
  .pill{background:#fff;padding:8px 12px;border-radius:999px;box-shadow:0 2px 6px var(--shadow);font-weight:800;}

  .debug-wrap{position:relative;}
  .debug-menu{position:absolute; right:0; top:44px; background:#fff; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.2); padding:8px; display:none; z-index:10; min-width:200px;}
  .debug-menu.show{display:block;}
  .debug-menu .menu-item{display:block; width:100%; text-align:left; border:none; background:#fff; padding:10px 12px; border-radius:10px; font-weight:700; box-shadow:0 2px 6px var(--shadow); margin:6px 0;}
  .debug-menu .menu-item.primary{background:var(--blue); color:#fff;}

  /* Board */
  #board{width:92vw; max-width:420px; aspect-ratio:8/10; margin:12px auto; padding:12px; background:#f4f6f9; border-radius:14px; box-shadow:0 10px 30px var(--shadow); position:relative;}
  #tiles{position:absolute; inset:0; display:grid; grid-template-columns:repeat(var(--cols,8),1fr); grid-template-rows:repeat(var(--rows,10),1fr); gap:12px;}

  /* Tiles */
  .tile{
    display:flex; align-items:center; justify-content:center;
    font-size: clamp(18px,7vw,42px); font-weight:900; color: var(--ink);
    user-select:none; position:relative;
    background:#eee; /* override inline per tile color */
    box-shadow: 0 6px 14px rgba(0,0,0,.18), inset 0 1px 0 rgba(255,255,255,.6), inset 0 -3px 0 rgba(0,0,0,.18);
    border-radius: 8px;
    transition: transform 260ms cubic-bezier(0.22, 1, 0.36, 1), box-shadow 140ms ease, filter 180ms ease; will-change: transform; 
    --ty: 0px; --sc: 1;
    transform: translateY(calc(var(--ty) + var(--fall, 0px))) scale(var(--sc));
  }
  .tile.selected{
    --sc: .95;
    box-shadow:
      0 0 0 3px #0aa inset,
      0 0 0 3px rgba(0,0,0,.2),
      0 10px 22px rgba(0,0,0,.22),
      inset 0 2px 0 rgba(255,255,255,.8),
      inset 0 -4px 0 rgba(0,0,0,.3);
  }
  .tile.glow{ animation: glow 800ms ease-out; }
  @keyframes glow{ 0%{ filter: drop-shadow(0 0 0 rgba(255,255,255,0)); } 50%{ filter: drop-shadow(0 0 12px rgba(255,255,255,1)); } 100%{ filter: drop-shadow(0 0 0 rgba(255,255,255,0)); } }

  .tile.explode{ animation: explode .22s ease-out forwards; }
  @keyframes explode{ 0%{ transform: translateY(calc(var(--ty) + var(--fall, 0px))) scale(1); opacity:1; } 100%{ transform: translateY(calc(var(--ty) - 12px)) scale(.6); opacity:0; filter: blur(1px); } }
  .tile.fall{ animation: fall .18s ease-out; }
  @keyframes fall{ 0%{ transform: translateY(calc(var(--ty) - 14px)) scale(1); } 100%{ transform: translateY(calc(var(--ty) + var(--fall, 0px))) scale(1); } }

  .tile.obstacle-stone{background:#bfc4cc;color:transparent;}
  .tile.obstacle-frozen{background:linear-gradient(135deg,#c9f2ff,#b6e0ff);} 
  .tile.obstacle-ice{background:linear-gradient(135deg,#c9f2ff,#b6e0ff);} 
  .tile.obstacle-bomb{background:radial-gradient(circle at 50% 40%, #444, #222); color:#fff; font-size: 24px;}
  .tile .badge{position:absolute;bottom:6px;right:6px;font-size:12px;font-weight:800;background:#111;color:#fff;padding:2px 6px;border-radius:999px;letter-spacing:.2px;opacity:.9;}
  .tile .ord{position:absolute; top:6px; left:6px; width:20px; height:20px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:12px; font-weight:800; background:#111; color:#fff; box-shadow:0 1px 3px rgba(0,0,0,.2);} 
  /* Large emoji when tile is a booster */
  .tile.power-emoji{ font-size: clamp(34px, 9.5vw, 68px); line-height: 1; }
  .tile .corner-ice{ position:absolute; top:6px; left:6px; font-size:16px; filter: drop-shadow(0 1px 1px rgba(0,0,0,.25)); }

  .tile.hint{ box-shadow: 0 0 0 3px #000 inset, 0 6px 18px rgba(0,0,0,.35); }
  .tile.debug{ outline:3px dashed rgba(255,0,110,.6); outline-offset:-3px; }

  .tile.breaker::after{content:\"\"; position:absolute; top:6px; left:6px; width:20px; height:20px; background-size:cover; background-image: var(--img-breaker);}
  .tile.breaker:not([style*=\"--img-breaker\"])::after{content:\"üî®\"; background-image:none; width:auto; height:auto; font-size:16px;}
  .tile.row::after{content:\"\"; position:absolute; top:6px; left:6px; width:20px; height:20px; background-size:cover; background-image: var(--img-row);} 
  .tile.row:not([style*=\"--img-row\"])::after{content:\"‚û°Ô∏è\"; background-image:none; width:auto; height:auto; font-size:16px;}
  .tile.col::after{content:\"\"; position:absolute; top:6px; left:6px; width:20px; height:20px; background-size:cover; background-image: var(--img-col);} 
  .tile.col:not([style*=\"--img-col\"])::after{content:\"‚¨áÔ∏è\"; background-image:none; width:auto; height:auto; font-size:16px;}
  .tile.rainbow::after{content:\"\"; position:absolute; top:6px; left:6px; width:20px; height:20px; background-size:cover; background-image: var(--img-rainbow);} 
  .tile.rainbow:not([style*=\"--img-rainbow\"])::after{content:\"üåà\"; background-image:none; width:auto; height:auto; font-size:16px;}
  .tile.rainbow{background:conic-gradient(from 0deg,#f9c,#9cf,#9fc,#fc9,#f9c);} 

  #board.targeting .tile{ cursor: crosshair; }

  /* Footer fixed bottom container */
  #footer{position:fixed; left:0; right:0; bottom:0; padding-bottom:env(safe-area-inset-bottom); z-index:8;}
  #footer .inner{max-width:480px; margin:0 auto;}
  #inventory{display:flex;gap:12px;justify-content:space-around;align-items:center;margin:6px 12px 8px 12px;}
  #bottom{width:100%; padding:14px 16px; display:flex; align-items:center; justify-content:center; background:#e9eaed; box-shadow:0 -2px 10px var(--shadow);} 
  #current-word{font-weight:900; letter-spacing:4px; font-size:20px; background:#fff; padding:10px 14px; border-radius:12px; box-shadow:0 2px 6px var(--shadow); min-width:200px; text-align:center;}

  #toast{position:fixed;top:10px;left:50%;transform:translateX(-50%);background:#111;color:#fff;padding:10px 14px;border-radius:10px;box-shadow:0 8px 20px rgba(0,0,0,.2);opacity:0;pointer-events:none;transition:opacity .2s ease;z-index:9;}

  .modal{position:fixed;inset:0;background:rgba(0,0,0,.5);display:flex;align-items:center;justify-content:center;z-index:20;}
  .modal[hidden]{display:none !important;}
  .modal-panel{background:#fff;border-radius:16px;max-width:420px;width:90vw;padding:18px;box-shadow:0 20px 50px rgba(0,0,0,.3);} 
  .modal h3{margin:0 0 8px 0;}
  .modal ol{margin:0 0 8px 18px;}
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="stat">
      <span class="pill"><span id="lblMoves">Moves</span> <span id="moves">20</span></span>
      <div class="goals-bar" id="goalsBar"></div>
    </div>
    <div class="debug-wrap">
      <button class="debug-badge" id="debugBtn" title="Open debug menu" aria-label="Debug">ü™≤</button>
      <div class="debug-menu" id="debugMenu">
        <div style="padding:6px 8px 2px 8px;font-weight:800;opacity:.8;">Idioma / Language</div>
        <select id="langSelect" class="menu-item" style="box-shadow:none;border:1px solid #ddd;">
          <option value="en">English</option>
          <option value="es">Espa√±ol</option>
        </select>
        <label class="menu-item" style="display:flex;align-items:center;gap:8px;">
          <input type="checkbox" id="wordDebugChk" /> Verbose word debug
        </label>
        <button class="menu-item" id="debugToggleOverlay">Toggle overlay</button>
        <button class="menu-item" id="shuffleBtn">Shuffle</button>
        <button class="menu-item" id="endTurnBtn">End Turn</button>
        <button class="menu-item" id="winNowBtn">Win Level</button>
      </div>
    </div>
  </header>

  <div id="board" aria-label="Game board"><div id="tiles"></div></div>
  
  <div id="footer"><div class="inner">
  <div id="inventory">
    <button class="inv-btn" data-type="breaker" title="Block breaker" style="width:56px;height:56px;border-radius:10px;border:0;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.15);display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:24px;">
      <span>üéØ</span><small class="inv-count" id="inv_breaker">5</small>
    </button>
    <button class="inv-btn" data-type="col" title="Column breaker" style="width:56px;height:56px;border-radius:10px;border:0;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.15);display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:24px;">
      <span style="display:inline-block;">‚¨ÜÔ∏è</span><small class="inv-count" id="inv_col">5</small>
    </button>
    <button class="inv-btn" data-type="row" title="Row breaker" style="width:56px;height:56px;border-radius:10px;border:0;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.15);display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:24px;">
      <span>ü•ä</span><small class="inv-count" id="inv_row">5</small>
    </button>
    <button class="inv-btn" data-type="rainbow" title="Wildcard" style="width:56px;height:56px;border-radius:10px;border:0;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.15);display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:24px;">
      <span>üÉè</span><small class="inv-count" id="inv_rainbow">5</small>
    </button>
  </div>
  <div id="bottom"><div id="current-word">____</div></div>
  </div></div>
</div>
<div id="toast"></div>

<div id="tutorial" class="modal" data-backdrop hidden>
  <div class="modal-panel">
    <h3>How to play</h3>
    <ol>
      <li id="tut1">Press and drag across adjacent letters (diagonals ok) to form a word.</li>
      <li id="tut2">Release to submit. If valid, tiles are removed and colors count toward goals.</li>
      <li id="tut3">Words of 4/5/6/7+ grant boosters: Breaker / Row / Column / Rainbow.</li>
      <li id="tut4">Use a booster by tapping its tile, then tap a target.</li>
    </ol>
    <button id="closeTutorial" class="debug-badge" style="background:#60a5fa">Got it</button>
  </div>
</div>

<footer style="max-width:1080px;margin:16px auto 28px;padding:12px 16px;color:#333;font-size:14px;line-height:1.5;">
  <strong>Boosters (actualizados):</strong>
  <ul style="margin:8px 0 0 18px; padding:0;">
    <li><strong>4 letras ‚Üí üî® Block breaker:</strong> toca el booster y luego una ficha para romper solo esa pieza.</li>
    <li><strong>5 letras ‚Üí ‚û°Ô∏è Row breaker:</strong> toca el booster y luego una ficha para romper toda la fila.</li>
    <li><strong>6 letras ‚Üí ‚¨áÔ∏è Column breaker:</strong> toca el booster y luego una ficha para romper toda la columna.</li>
    <li><strong>7+ letras ‚Üí üåà Rainbow (comod√≠n):</strong> √∫salo dentro de una palabra; puede reemplazar cualquier letra/color.</li>
  </ul>
</footer>

<!-- Optional embedded assets for file:// debugging. Paste your JSON/word lists here. -->
<script type="application/json" id="embedded_level_1">{ 
  "cols": 8, "rows": 10,
  "objectives": {"yellow":20,"green":20,"blue":20,"ice":0,"fire":0},
  "grid": []
}</script>
<script type="application/json" id="embedded_level_2">{ 
  "cols": 8, "rows": 10,
  "objectives": {"yellow":18,"green":18,"blue":18,"ice":0,"fire":0},
  "grid": []
}</script>
<!-- For English, paste newline-separated words inside this tag for file:// tests. -->
<script type="text/plain" id="embedded_dict_en"></script>
<!-- For Spanish, paste a JSON array of words inside this tag for file:// tests. -->
<script type="application/json" id="embedded_dict_es">[]</script>

<script>
(function(){
  let COLS=8, ROWS=10;

  // === Language + remote dictionaries ===
  let currentLang = (()=>{ try{ return localStorage.getItem('lexica_lang') || 'en'; }catch(_){ return 'en'; } })();
  var isIOS = (function(){ var ua=(navigator&&navigator.userAgent)?navigator.userAgent:''; return /iPhone|iPad|iPod/i.test(ua); })();
  var IS_FILE = (function(){ try{ return location && location.protocol === 'file:'; }catch(_){ return false; } })();

  const STRINGS = {
    en:{moves:'Moves',tut1:'Press and drag across adjacent letters (diagonals ok) to form a word.',tut2:'Release to submit. If valid, tiles are removed and colors count toward goals.',tut3:'Words of 4/5/6/7+ grant boosters: Breaker / Row / Column / Rainbow.',tut4:'Use a booster by tapping its tile, then tap a target.',shuffled:'Shuffled',turnEnded:'Turn ended',outOfMoves:'Out of moves',lvlUp:'Level up',notValid:'Not a valid word',powerCreated:'Power-up created!',objectivesDone:'Objectives complete!',dictLoading:'Loading dictionary‚Ä¶',dictReady:'Dictionary ready',dictFallback:'Dictionary offline ‚Äî fallback'},
    es:{moves:'Movimientos',tut1:'Mant√©n presionado y arrastra por letras adyacentes (diagonales tambi√©n) para formar una palabra.',tut2:'Suelta para enviar. Si es v√°lida, se eliminan las fichas y sus colores cuentan al objetivo.',tut3:'Palabras de 4/5/6/7+ otorgan poderes: Rompe-bloque / Rompe-fila / Rompe-columna / Comod√≠n.',tut4:'Usa un poder tocando su ficha y luego el objetivo.',shuffled:'Mezclado',turnEnded:'Turno finalizado',outOfMoves:'Sin movimientos',lvlUp:'Nivel superado',notValid:'Palabra inv√°lida',powerCreated:'¬°Poder creado!',objectivesDone:'¬°Objetivos completos!',dictLoading:'Cargando diccionario‚Ä¶',dictReady:'Diccionario listo',dictFallback:'Diccionario offline ‚Äî fallback'}
  };

  const DICT_URL_EN = 'https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt';
  const DICT_URL_ES = 'https://raw.githubusercontent.com/words/an-array-of-spanish-words/master/index.json';
  const LOCAL_DICT_EN = 'data/english_words.txt';
  const LOCAL_DICT_ES = 'data/spanish_words.json';
  function relUrl(p){ try{ return new URL(p, location.href).toString(); }catch(_){ return p; } }
  const dictCache={en:null, es:null}, prefCache={en:null, es:null};
  var dictLoading=false;
  function normalizeWord(lang, w){
    var s=String(w||'').toUpperCase();
    if(lang==='es'){
      try{ s=s.normalize('NFD').replace(/[\u0300-\u036f]/g,''); }catch(_){ /* no-op */ }
      // map √ë -> N (tiles are A-Z)
      s=s.replace(/√ë/g,'N');
    }
    return s;
  }
  function sleep(ms){ return new Promise(function(r){ setTimeout(r, ms); }); }
  async function buildSetsBatched(words, opts){
    opts = opts || {}; var cap = opts.cap||Infinity, maxLen = opts.maxLen||Infinity, prefixDepth = opts.prefixDepth||Infinity, batch = opts.batch||5000;
    // Preprocess: trim, length filter, normalize and sort by length (then alpha) to keep common short words first
    var pre = [];
    for(var i=0;i<words.length;i++){ var w=words[i]; if(!w) continue; var s=String(w).trim(); if(s.length<3||s.length>maxLen) continue; pre.push(s); }
    pre.sort(function(a,b){ if(a.length!==b.length) return a.length-b.length; a=a.toUpperCase(); b=b.toUpperCase(); return a<b?-1:(a>b?1:0); });
    var dict=new Set(), pref=new Set(); var count=0;
    for(var k=0;k<pre.length;k++){
      var up = normalizeWord(currentLang, pre[k]);
      dict.add(up); var maxP = Math.min(up.length, prefixDepth);
      for(var j=1;j<=maxP;j++){ pref.add(up.slice(0,j)); }
      count++;
      if(count>=cap) break;
      if(k>0 && (k%batch===0)) await sleep(0);
    }
    return {dict, pref};
  }
  async function loadDictionary(lang){
    if(dictCache[lang] && prefCache[lang]) return {dict:dictCache[lang], pref:prefCache[lang]};
    dictLoading=true; toast((STRINGS[currentLang]||STRINGS.en).dictLoading);
    try{
      if(IS_FILE){
        console.warn('file:// detected ‚Äî trying embedded dictionaries');
        let words=null;
        if(lang==='en'){
          const el=document.getElementById('embedded_dict_en');
          if(el){ const txt=el.textContent||''; words=txt.split(/\r?\n/).filter(Boolean); }
        }else{
          const el=document.getElementById('embedded_dict_es');
          if(el){ try{ words=JSON.parse(el.textContent||'[]'); }catch(_e){} }
        }
        if(words && words.length){
          var opts = {cap:50000, maxLen:12, prefixDepth:12, batch:4000};
          const built=await buildSetsBatched(words, opts);
          dictCache[lang]=built.dict; prefCache[lang]=built.pref; dictLoading=false; toast((STRINGS[currentLang]||STRINGS.en).dictReady);
          return {dict:built.dict, pref:built.pref};
        } else {
          dictLoading=false; toast((STRINGS[currentLang]||STRINGS.en).dictFallback + ' (file mode)');
          return {dict:dictionary, pref:prefixes};
        }
      }
      var opts = isIOS ? {cap:50000, maxLen:12, prefixDepth:12, batch:4000} : {cap:Infinity, maxLen:12, prefixDepth:12, batch:12000};
      if(lang==='en'){
        var words;
        try{
          const rLocal=await fetch(relUrl(LOCAL_DICT_EN), {cache:'no-store'}); const txtL=await rLocal.text();
          words=txtL.split(/\\r?\\n/).filter(function(w){return w;});
        }catch(_e){
          const r=await fetch(DICT_URL_EN, {mode:'cors'}); const txt=await r.text();
          words=txt.split(/\\r?\\n/).filter(function(w){return w;});
        }
        const built=await buildSetsBatched(words, opts);
        dictCache.en=built.dict; prefCache.en=built.pref; dictLoading=false; toast((STRINGS[currentLang]||STRINGS.en).dictReady); return {dict:built.dict,pref:built.pref};
      }else{
        var wordsES;
        try{
          const rLocal=await fetch(relUrl(LOCAL_DICT_ES), {cache:'no-store'}); const arrL=await rLocal.json();
          wordsES=arrL;
        }catch(_e2){
          const r=await fetch(DICT_URL_ES, {mode:'cors'}); const arr=await r.json();
          wordsES=arr;
        }
        const built=await buildSetsBatched(wordsES, opts);
        dictCache.es=built.dict; prefCache.es=built.pref; dictLoading=false; toast((STRINGS[currentLang]||STRINGS.en).dictReady); return {dict:built.dict,pref:built.pref};
      }
    }catch(e){
      console.warn('Dictionary load failed', lang, e);
      dictLoading=false; toast((STRINGS[currentLang]||STRINGS.en).dictFallback);
      // Fallback to local minimal sets (built below)
      return {dict:dictionary, pref:prefixes};
    }
  }

  function applyLanguageToUI(){
    const s=STRINGS[currentLang]||STRINGS.en;
    const lm=document.getElementById('lblMoves'); if(lm) lm.textContent=s.moves;
    const t1=document.getElementById('tut1'); if(t1) t1.textContent=s.tut1;
    const t2=document.getElementById('tut2'); if(t2) t2.textContent=s.tut2;
    const t3=document.getElementById('tut3'); if(t3) t3.textContent=s.tut3;
    const t4=document.getElementById('tut4'); if(t4) t4.textContent=s.tut4;
  }

  const vowels="AEIOU";
  let lettersBag=[..."EEEEEEEEEEEEAAAAAAAIIIIIIIOOOOOONNNNNNRRRRRRTTTTTTLLLLSSSSUUUUDDDDGGGBBCCMMPPFFHHVVWWYKJXQZ"];
  function setLetterWeights(weights){
    if(!weights){ return; }
    const seq=[]; const scale=10; // scale percentages to counts
    Object.keys(weights).forEach(k=>{
      const v=parseFloat(weights[k]||0); if(v<=0) return;
      const n=Math.max(1, Math.round(v*scale));
      for(let i=0;i<n;i++) seq.push(String(k).toUpperCase());
    });
    if(seq.length>=5) lettersBag=seq;
  }

  // Dynamic color weights (percentages). Supports: yellow, green, blue, purple, red
  const COLOR_HEX={yellow:'#fcd34d', green:'#34d399', blue:'#60a5fa', purple:'#a78bfa', red:'#ef4444', booster:'#a87657'};
  let colorWeightsMap={yellow:40, green:30, blue:20, purple:10};
  function setColorWeights(map){ if(!map) return; colorWeightsMap={...colorWeightsMap, ...map}; }
  function pickWeightedKey(map){ const entries=Object.entries(map).filter(([k,v])=>v>0); const total=entries.reduce((s,[,v])=>s+Number(v||0),0) || 1; let r=Math.random()*total; for(const [k,v] of entries){ r-=Number(v||0); if(r<=0) return k; } return entries[0]?.[0]||'yellow'; }
  function pickColor(){ const key=pickWeightedKey(colorWeightsMap); return {key, color: (COLOR_HEX[key]||'#fcd34d')}; }

  const hexToRgb=h=>{const x=h.replace('#','');const n=parseInt(x.length===3?x.split('').map(c=>c+c).join(''):x,16);return{r:(n>>16)&255,g:(n>>8)&255,b:n&255}};
  const relL=({r,g,b})=>{const s=[r,g,b].map(v=>{v/=255;return v<=.03928?v/12.92:Math.pow((v+.055)/1.055,2.4)});return .2126*s[0]+.7152*s[1]+.0722*s[2]};
  const readable=bg=>relL(hexToRgb(bg))>0.5?'#111':'#fff';
  const tint=(hex,amt)=>{const {r,g,b}=hexToRgb(hex);const m=c=>Math.min(255,Math.round(c+(255-c)*amt));const rr=m(r),gg=m(g),bb=m(b);return '#'+[rr,gg,bb].map(v=>v.toString(16).padStart(2,'0')).join('')};

  // small local fallback dic
  const wordList=["ABLE","ABOUT","APPLE","POOL","HOUSE","LIGHT","GREEN","BLUE","YELLOW","WORLD","STONE","FROZEN","LEVEL","MOVE","GOAL","ROOM","ROAD","WATER","PLAY","WORD","WORDS","BOOK","BOOKS"];
  const dictionary=new Set(wordList.map(w=>w.toUpperCase()));
  const prefixes=new Set(); for(const w of wordList){const u=w.toUpperCase(); for(let i=1;i<=u.length;i++) prefixes.add(u.slice(0,i));}

  const boardEl=document.getElementById('board');
  const tilesEl=document.getElementById('tiles');
  const movesEl=document.getElementById('moves');
  const toastEl=document.getElementById('toast');
  const debugBtn=document.getElementById('debugBtn');
  const debugMenu=document.getElementById('debugMenu');
  const debugToggleOverlayBtn=document.getElementById('debugToggleOverlay');
  const shuffleBtn=document.getElementById('shuffleBtn');
  const endTurnBtn=document.getElementById('endTurnBtn');
  const tutorialEl=document.getElementById('tutorial');
  const closeTutorialBtn=document.getElementById('closeTutorial');

  let level=1, moves=20, grid=[], selection=[], selecting=false, selectingPointerId=null;
  let hintTimer=null; const HINT_DELAY_MS=8000; let currentHint=null;
  let debugMode=false, targeting=null, submitting=false;
  let verboseWordDebug=false;
  let inventory={breaker:5,row:5,col:5,rainbow:5};

  tilesEl.style.setProperty('--cols',COLS);
  tilesEl.style.setProperty('--rows',ROWS);
  // Fixed phone-like sizing for tiles
  let CELL_PX=44; const GAP_PX=12, PAD_PX=12;
  function footerHeight(){ const f=document.getElementById('footer'); return f? f.getBoundingClientRect().height : 0; }
  function headerHeight(){ const h=document.querySelector('header'); return h? h.getBoundingClientRect().height : 0; }
  function ensureBoardSize(){
    // Try to fit board between header and footer; scale down CELL_PX if needed
    const fudge = 32; // extra breathing room for margins/shadows
    const availH = window.innerHeight - headerHeight() - footerHeight() - fudge;
    const neededH = PAD_PX*2 + ROWS*CELL_PX + (ROWS-1)*GAP_PX;
    if(availH < neededH){
      const cell = Math.max(36, Math.floor((availH - PAD_PX*2 - (ROWS-1)*GAP_PX) / ROWS));
      CELL_PX = cell;
    }else{
      CELL_PX = 44;
    }
    const w = PAD_PX*2 + COLS*CELL_PX + (COLS-1)*GAP_PX;
    const h = PAD_PX*2 + ROWS*CELL_PX + (ROWS-1)*GAP_PX;
    boardEl.style.width = w+'px';
    boardEl.style.height = h+'px';
    boardEl.style.aspectRatio='';
    tilesEl.style.gap = GAP_PX+'px';
    document.getElementById('app').style.paddingBottom = footerHeight() + 'px';
  }

  const cellSizePx=()=>CELL_PX;
  const idx=(r,c)=>r*COLS+c;
  const rc=i=>[Math.floor(i/COLS),i%COLS];
  const inBounds=(r,c)=>r>=0&&c>=0&&r<ROWS&&c<COLS;

  const randLetter=()=>{const pick=lettersBag[Math.floor(Math.random()*lettersBag.length)];return Math.random()<0.12?vowels[Math.floor(Math.random()*vowels.length)]:pick;};
  const newTile=()=>{const col=pickColor();return{letter:randLetter(),colorKey:col.key,color:col.color,obstacle:null,frozen:false,power:null}};

  function placeIceBlockers(){
    // Coordinates are (row, col), 0-indexed as provided
    const coords=[[1,1],[1,6],[4,3],[4,4],[7,1],[7,6]];
    for(const [r,c] of coords){ if(inBounds(r,c)){ const i=idx(r,c); grid[i]={letter:null,colorKey:null,color:'#b6e0ff',obstacle:'ice',frozen:false,power:null}; } }
  }

  function makeEmpty(){grid=Array.from({length:ROWS*COLS},()=>null);}
  function placeInitial(){for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) grid[idx(r,c)]=newTile();}

  function render(){
    tilesEl.innerHTML='';
    const cs=getComputedStyle(tilesEl); const gap=parseFloat(cs.gap)||0; const h=tilesEl.clientHeight; const trackH=(h - (ROWS-1)*gap)/ROWS; const emojiSize=Math.max(18, Math.floor(trackH*0.82));
    grid.forEach((cell,i)=>{
      const div=document.createElement('div'); div.className='tile'; div.dataset.i=i;
      if(cell){
        if(cell.obstacle==='stone'){div.classList.add('obstacle-stone');}
        else if(cell.obstacle==='bomb'){div.classList.add('obstacle-bomb'); div.textContent='üß®';}
        else if(cell.obstacle==='fire'){
          const stage=cell.stage||1; const emoji = stage===1?'üß®':(stage===2?'üî•':'üî•');
          div.style.background='linear-gradient(135deg,#ffd3c1,#ff9f80)'; const span=document.createElement('span'); span.textContent=emoji; span.style.fontSize=emojiSize+'px'; div.appendChild(span);
        }
        else if(cell.obstacle==='ice'){div.classList.add('obstacle-ice'); const span=document.createElement('span'); span.textContent='üßä'; span.style.fontSize=emojiSize+'px'; if(cell.layers&&cell.layers>1){ const b=document.createElement('span'); b.className='badge'; b.textContent='√ó'+cell.layers; div.appendChild(b);} div.appendChild(span);}
        else{
          // Background and text color
          const top=tint(cell.color,.22); div.style.background=`linear-gradient(135deg, ${top}, ${cell.color})`;
          div.style.color=readable(cell.color);
          // Frozen overlay
          if(cell.frozen){ div.classList.add('obstacle-frozen'); const ice=document.createElement('span'); ice.className='corner-ice'; ice.textContent='üßä'; div.appendChild(ice); }
          // Booster emoji replaces the letter completely
          if(cell.power){
            const emoji = cell.power==='rainbow'?'üÉè':(cell.power==='breaker'?'üî®':(cell.power==='row'?'‚ÜîÔ∏è':'‚ÜïÔ∏è'));
            const span=document.createElement('span'); span.className='booster-emoji'; span.textContent=emoji; span.style.fontSize=emojiSize+'px'; div.appendChild(span); div.classList.add('power-emoji');
          }else{
            div.textContent=cell.letter;
          }
        }
      }else div.style.visibility='hidden';
      tilesEl.appendChild(div);
    });
  }

  const isAdjacent=(a,b)=>{const[ar,ac]=rc(a),[br,bc]=rc(b);return Math.max(Math.abs(ar-br),Math.abs(ac-bc))===1;}
  const indexFromPoint=(x,y)=>{ const el=document.elementFromPoint(x,y); const tile=el && el.closest ? el.closest('.tile') : null; return tile ? Number(tile.dataset.i) : -1; };

  function getCurrentWord(){ return selection.map(function(i){ return (grid[i] && grid[i].letter) || ''; }).join(''); }
  function updateWordDisplay(){const el=document.getElementById('current-word'); if(!el) return; const w=getCurrentWord(); el.textContent=w ? w : '____';}
  function updateInventoryUI(){ const map={breaker:'inv_breaker',row:'inv_row',col:'inv_col',rainbow:'inv_rainbow'}; Object.keys(map).forEach(k=>{ const el=document.getElementById(map[k]); if(el) el.textContent=inventory[k]||0; }); }
  function updateSelClasses(){
    document.querySelectorAll('.tile').forEach(t=>{ t.classList.remove('selected'); const o=t.querySelector('.ord'); if(o) o.remove(); });
    selection.forEach((i,ord)=>{ const el=tilesEl.querySelector(`.tile[data-i='${i}']`); if(el){ el.classList.add('selected'); const s=document.createElement('span'); s.className='ord'; s.textContent=String(ord+1); el.appendChild(s);} });
    updateWordDisplay();
  }
  function clearSelection(){selection=[]; updateSelClasses();}

  function startSelect(i){
    clearTimeout(hintTimer); if(submitting) return; const t=grid[i];
    if(!t || t.obstacle==='stone' || t.obstacle==='bomb' || t.obstacle==='ice' || t.power) return; // power tiles and ice are not letters
    selecting=true; selection=[i]; updateSelClasses();
  }
  function extendTo(i){
    if(!selecting) return; if(i<0) return; const t=grid[i];
    if(!t || t.obstacle==='stone' || t.obstacle==='bomb' || t.obstacle==='ice' || t.power) return; // skip power/ice
    const last=selection[selection.length-1]; if(i===last) return;
    if(selection.length>=2 && i===selection[selection.length-2]){selection.pop(); updateSelClasses(); return;}
    const pos=selection.indexOf(i); if(pos!==-1){selection=selection.slice(0,pos+1); updateSelClasses(); return;}
    if(isAdjacent(last,i)){selection.push(i); updateSelClasses();}
  }
  function finishSelect(){if(!selecting) return; selecting=false; if(selection.length>1 && selection[selection.length-1]===selection[0]){clearSelection(); scheduleHint(); return;} if(selection.length<3){clearSelection(); scheduleHint(); return;} endSelect();}

  async function isValidWordAsync(w){ if(!w||w.length<3) return false; const u=normalizeWord(currentLang, w); const {dict}=await loadDictionary(currentLang); return dict.has(u); }

  function toast(msg){toastEl.textContent=msg; toastEl.style.opacity=1; clearTimeout(toastEl._t); toastEl._t=setTimeout(()=>toastEl.style.opacity=0,1200);}
  function shakeBoard(){ boardEl.animate([{transform:'translateX(0)'},{transform:'translateX(-8px)'},{transform:'translateX(8px)'},{transform:'translateX(0)'}],{duration:220}); toast(STRINGS[currentLang].notValid); }

  async function endSelect(){ if(submitting) return; submitting=true; const w=getCurrentWord(); const ok=await isValidWordAsync(w); if(!ok){ debugWordInfo(w); shakeBoard(); clearSelection(); scheduleHint(); submitting=false; return;} resolveWord(w); submitting=false; }
  function debugWordInfo(word){
    if(!verboseWordDebug) return;
    (async function(){
      try{
        const sets=await loadDictionary(currentLang); const u=normalizeWord(currentLang, word);
        const has=sets.dict.has(u); const pre=sets.pref.has(u); const size=sets.dict.size; const pl=u.length;
        const msg=`${currentLang.toUpperCase()}: '${u}' present=${has} prefix=${pre} len=${pl} dictSize=${size} iOS=${isIOS}`;
        console.log('[WordDebug]', msg); toast(msg);
      }catch(e){ console.log('[WordDebug] error', e); }
    })();
  }

  // Goals by color
  let goals={yellow:20, green:20, blue:20, purple:0, red:0, ice:0, fire:0};
  const goalsBar=document.getElementById('goalsBar');
  function renderGoalsBar(){ if(!goalsBar) return; goalsBar.innerHTML=''; const entries=[['blue',''],['yellow',''],['green',''],['purple',''],['red',''],['ice','üßä']]; entries.forEach(([key,emoji])=>{ const val=Number(goals[key]||0); if(val>0){ const item=document.createElement('div'); item.className='goal-item'; const sw=document.createElement('div'); sw.className='goal-swatch'; if(key==='ice'){ sw.style.background='#b6e0ff'; sw.style.display='flex'; sw.style.alignItems='center'; sw.style.justifyContent='center'; sw.textContent='üßä'; } else { sw.style.background=COLOR_HEX[key]||'#ddd'; }
      const num=document.createElement('div'); num.className='goal-num'; num.id='goal_'+key; num.textContent=val; item.appendChild(sw); item.appendChild(num); goalsBar.appendChild(item);} }); }
  const updateGoalsUI=()=>{ renderGoalsBar(); Object.keys(goals).forEach(k=>{ const el=document.getElementById('goal_'+k); if(el) el.textContent=goals[k]; }); };
  function goalsComplete(){ for(const [k,v] of Object.entries(goals)){ if(Number(v||0)>0){ return false; } } return true; }

  function setProceduralGoals(total){
    total = total || 60; // default total colored tiles to collect
    const keys=['yellow','green','blue','purple','red'];
    const weights = keys.map(k=>Number(colorWeightsMap[k]||0));
    const sum = weights.reduce((a,b)=>a+b,0) || 1;
    // initial distribution
    let distrib = keys.map((k,i)=>({k, v: Math.floor(total * (weights[i]/sum)) }));
    // spread remainder to highest weights
    let assigned = distrib.reduce((a,o)=>a+o.v,0); let rem = total - assigned;
    const order = [...distrib].sort((a,b)=> (colorWeightsMap[b.k]||0)-(colorWeightsMap[a.k]||0));
    for(let i=0; i<order.length && rem>0; i++){ order[i].v++; rem--; }
    // rebuild goals
    goals.yellow=goals.green=goals.blue=goals.purple=goals.red=0; goals.ice=goals.fire=0;
    distrib.forEach(o=>{ goals[o.k]=o.v; }); updateGoalsUI();
  }

  function spendMove(){ moves=Math.max(0,moves-1); movesEl.textContent=moves; }
  async function nextLevel(){ level++; moves=20; movesEl.textContent=moves; inventory={breaker:5,row:5,col:5,rainbow:5}; updateInventoryUI(); makeEmpty(); let ok=await loadLevelFromData(level,true); if(!ok){ ok=await loadLevelFromData(1,false); if(!ok){ setProceduralGoals(60); placeInitial(); level=1; } } render(); refreshDebugOverlay(); toast(STRINGS[currentLang].lvlUp); spawnConfetti(); }

  function resolveWord(word){
    const len=selection.length; let newPower=null;
    if(len>=7) newPower='rainbow'; else if(len===6) newPower='col'; else if(len===5) newPower='row'; else if(len===4) newPower='breaker';
    const toRemove=new Set(selection);
    const colorCount={yellow:0,green:0,blue:0,purple:0,red:0};
    selection.forEach(i=>{const t=grid[i]; if(t && t.frozen){ t.frozen=false; toRemove.delete(i); }});
    const bombsToExplode=new Set();
    // Break adjacent ICE blockers -> convert to fresh letters and count towards ice goal
    const iceToHit=new Set(); const firesToRemove=new Set();
    selection.forEach(i=>{ const [r,c]=rc(i); for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ const nr=r+dr,nc=c+dc; if(dr===0&&dc===0) continue; if(!inBounds(nr,nc)) continue; const j=idx(nr,nc); const cell=grid[j]; if(!cell) continue; if(cell.obstacle==='ice') iceToHit.add(j); if(cell.obstacle==='fire') firesToRemove.add(j); if(cell.obstacle==='bomb'){ cell.state=(cell.state||0)+1; if(cell.state>=2) bombsToExplode.add(j); } }});
    const stonesToRemove=new Set();
    toRemove.forEach(i=>{const [r,c]=rc(i); for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0) continue; const nr=r+dr,nc=c+dc; if(inBounds(nr,nc)){ const j=idx(nr,nc); if(grid[j] && grid[j].obstacle==='stone') stonesToRemove.add(j); } }});
    toRemove.forEach(i=>{const t=grid[i]; if(t && !t.obstacle && t.colorKey && colorCount[t.colorKey]!=null) colorCount[t.colorKey]++; grid[i]=null;});
    stonesToRemove.forEach(i=>grid[i]=null);
    let iceBrokenCount=0, fireClearedCount=0;
    iceToHit.forEach(j=>{ const t=grid[j]; if(t.layers && t.layers>1){ t.layers--; } else { grid[j]=newTile(); iceBrokenCount++; } });
    firesToRemove.forEach(j=>{ grid[j]=null; fireClearedCount++; });
    bombsToExplode.forEach(bi=>{const [r,c]=rc(bi); const affected=new Set([bi]); for(let rr=0; rr<ROWS; rr++) affected.add(idx(rr,c)); for(let cc=0; cc<COLS; cc++) affected.add(idx(r,cc)); affected.forEach(ai=>{const t=grid[ai]; if(t && !t.obstacle && t.colorKey && colorCount[t.colorKey]!=null) colorCount[t.colorKey]++; grid[ai]=null;});});
    if(newPower){
      const last=selection[selection.length-1]; let tIdx=last; if(grid[tIdx]!==null){ var arr=Array.from(toRemove); tIdx = (arr.length>0?arr[0]:last); }
      // Use a distinctive brown background for boosters
      if(tIdx!=null) grid[tIdx]={letter:'', colorKey:'booster', color:'#a87657', obstacle:null, frozen:false, power:newPower};
      toast(STRINGS[currentLang].powerCreated);
    }
    goals.yellow=Math.max(0,goals.yellow-(colorCount.yellow||0));
    goals.green=Math.max(0,goals.green-(colorCount.green||0));
    goals.blue=Math.max(0,goals.blue-(colorCount.blue||0));
    goals.purple=Math.max(0,(goals.purple||0)-(colorCount.purple||0));
    goals.red=Math.max(0,(goals.red||0)-(colorCount.red||0));
    goals.ice=Math.max(0,(goals.ice||0)-iceBrokenCount);
    goals.fire=Math.max(0,(goals.fire||0)-fireClearedCount);
    recountDynamicObjectives(); updateGoalsUI();
    const movesMap=applyGravity(); refill(); processFireAfterMove(); scheduleHint(); refreshDebugOverlay();
    const px=cellSizePx(); Object.entries(movesMap).forEach(([to,d])=>{const el=boardEl.querySelector(`.tile[data-i='${to}']`); if(el) el.style.setProperty('--fall',`${-d*px}px`);}); requestAnimationFrame(()=>{Object.keys(movesMap).forEach(to=>{const el=boardEl.querySelector(`.tile[data-i='${to}']`); if(el) el.style.setProperty('--fall','0px');});});
    clearSelection(); spendMove();
    if(goalsComplete()){ toast(STRINGS[currentLang].objectivesDone); spawnConfetti(); nextLevel(); return; }
    if(moves===0){ showLoseModal(); }
  }

  function applyGravity(){ const moves={}; for(let c=0;c<COLS;c++){ let write=ROWS-1; for(let r=ROWS-1;r>=0;r--){ const i=idx(r,c), cell=grid[i]; if(cell){ if(cell.obstacle==='stone' || cell.obstacle==='ice'){ write=r-1; continue; } if(write!==r){ const wi=idx(write,c); grid[wi]=cell; grid[i]=null; moves[wi]=(moves[wi]||0)+(write-r);} write--; } } } return moves; }
  function refill(){ for(let c=0;c<COLS;c++) for(let r=0;r<ROWS;r++){ const i=idx(r,c); if(grid[i]===null) grid[i]=newTile(); } render(); }

  function recountDynamicObjectives(){
    // sync ice/fire objectives with current board if those objectives are enabled
    if(goals && typeof goals.ice==='number'){
      let c=0; for(let i=0;i<grid.length;i++){ const t=grid[i]; if(t && t.obstacle==='ice') c++; } goals.ice=c; }
    if(goals && typeof goals.fire==='number'){
      let f=0; for(let i=0;i<grid.length;i++){ const t=grid[i]; if(t && t.obstacle==='fire') f++; } goals.fire=f; }
  }
  function processFireAfterMove(){
    // Final behavior:
    // 1) Stage 1 (üß®) that survives -> becomes Stage 2 (üî•) in place.
    // 2) Stage 2 (üî•) that survives -> moves to one random adjacent eligible cell as Stage 2 (üî•).
    const moves=[]; // {from,to}
    for(let i=0;i<grid.length;i++){
      const t=grid[i]; if(!t || t.obstacle!=='fire') continue; if(!t.stage) t.stage=1;
      if(t.stage===1){
        // convert in place to active fire
        t.stage=2;
      }else if(t.stage===2){
        // move to adjacent eligible cell
        const [r,c]=rc(i); const candidates=[];
        for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
          if(dr===0&&dc===0) continue; const nr=r+dr,nc=c+dc; if(!inBounds(nr,nc)) continue; const j=idx(nr,nc);
          const cell=grid[j]; if(cell && (cell.obstacle==='stone' || cell.obstacle==='ice' || cell.obstacle==='fire')) continue; candidates.push(j);
        }
        if(candidates.length){ const j=candidates[Math.floor(Math.random()*candidates.length)]; moves.push({from:i,to:j}); }
      }
    }
    // apply moves (propagation: keep original, add new üî• on destination)
    moves.forEach(({from,to})=>{ grid[to]={letter:null,colorKey:null,color:'#ffaf87',obstacle:'fire',stage:2}; /* keep original as üî• */ });
    recountDynamicObjectives(); render();
  }

  function clearHint(){ currentHint=null; document.querySelectorAll('.tile.hint').forEach(e=>e.classList.remove('hint')); document.querySelectorAll('.hint-ord').forEach(e=>e.remove()); }
  function scheduleHint(){ clearTimeout(hintTimer); if(dictLoading) return; hintTimer=setTimeout(function(){ if(!dictLoading) showAnyHint(); }, HINT_DELAY_MS); }
  function showHintPath(path){ path.forEach((i,ord)=>{ const el=boardEl.querySelector(`.tile[data-i='${i}']`); if(el){ el.classList.add('hint'); const b=document.createElement('span'); b.className='ord hint-ord'; b.textContent=String(ord+1); el.appendChild(b); } }); }
  async function showAnyHint(){
    if(dictLoading) return;
    clearHint(); const {dict,pref}=await loadDictionary(currentLang);
    const visited=new Array(ROWS*COLS).fill(false); const maxLen=isIOS?5:6; let found=null;
    function dfs(path){ if(found) return; var word=path.map(function(i){ return (grid[i]&&grid[i].letter)||''; }).join('').toUpperCase(); if(!pref.has(word)) return; if(word.length>=3 && dict.has(word)){ found=path.slice(); return;} if(path.length===maxLen) return; const last=path[path.length-1]; const _rc=rc(last); const r=_rc[0], c=_rc[1]; for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0) continue; const nr=r+dr,nc=c+dc; if(!inBounds(nr,nc)) continue; const j=idx(nr,nc); if(visited[j]) continue; const cell=grid[j]; if(!cell || cell.obstacle==='stone' || cell.obstacle==='bomb' || cell.obstacle==='ice' || cell.power) continue; visited[j]=true; path.push(j); dfs(path); path.pop(); visited[j]=false; if(found) return; }}
    for(let i=0;i<ROWS*COLS && !found;i++){ const cell=grid[i]; if(!cell || cell.obstacle==='stone' || cell.obstacle==='bomb' || cell.obstacle==='ice' || cell.power) continue; visited[i]=true; dfs([i]); visited[i]=false; }
    if(found){ currentHint=found; showHintPath(found); }
  }

  function clearDebug(){ document.querySelectorAll('.tile.debug').forEach(el=>el.classList.remove('debug')); }
  function drawDebugPaths(list){ clearDebug(); const maxDraw=Math.min(list.length,80); for(let n=0;n<maxDraw;n++){ const p=list[n].path; for(let k=0;k<p.length;k++){ const el=boardEl.querySelector(`.tile[data-i='${p[k]}']`); if(el) el.classList.add('debug'); } } }
  async function findAllWordsOnBoard(){
    if(dictLoading) return [];
    const {dict,pref}=await loadDictionary(currentLang); const results=[]; const visited=new Array(ROWS*COLS).fill(false); const maxLen=isIOS?5:7; const cap=isIOS?100:200;
    function dfs(path){ const word=path.map(function(i){ return (grid[i]&&grid[i].letter)||''; }).join('').toUpperCase(); if(!pref.has(word)) return; if(word.length>=3 && dict.has(word)){ results.push({word:word, path:path.slice()}); if(results.length>cap) return; } if(path.length===maxLen) return; const last=path[path.length-1]; const _rc=rc(last); const r=_rc[0], c=_rc[1]; for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0) continue; const nr=r+dr,nc=c+dc; if(!inBounds(nr,nc)) continue; const j=idx(nr,nc); if(visited[j]) continue; const cell=grid[j]; if(!cell || cell.obstacle==='stone' || cell.obstacle==='bomb' || cell.obstacle==='ice' || cell.power) continue; visited[j]=true; path.push(j); dfs(path); path.pop(); visited[j]=false; if(results.length>cap) return; } }
    for(let i=0;i<ROWS*COLS;i++){ const cell=grid[i]; if(!cell || cell.obstacle==='stone' || cell.obstacle==='bomb' || cell.obstacle==='ice' || cell.power) continue; visited[i]=true; dfs([i]); visited[i]=false; if(results.length>cap) break; }
    return results;
  }
  async function refreshDebugOverlay(){ if(!debugMode){ clearDebug(); return; } if(dictLoading){ clearDebug(); toast('Loading dictionary‚Ä¶'); return; } const list=await findAllWordsOnBoard(); drawDebugPaths(list); toast(list.length+' words'); }

  // Events
  boardEl.addEventListener('pointerdown',(e)=>{const i=indexFromPoint(e.clientX,e.clientY); if(i>=0){ if(targeting){ applyTargeting(i); return;} const t=grid[i]; if(!selecting && t && t.power){ if(t.power==='row' || t.power==='col'){ useSelfPower(i); return;} enterTargeting(t.power,i); return;} startSelect(i); try{boardEl.setPointerCapture(e.pointerId); selectingPointerId=e.pointerId;}catch{}}});
  boardEl.addEventListener('pointermove',(e)=>{if(!selecting) return; const i=indexFromPoint(e.clientX,e.clientY); if(i>=0) extendTo(i);});
  boardEl.addEventListener('pointerup',()=>{if(selecting) finishSelect(); if(selectingPointerId!=null){try{boardEl.releasePointerCapture(selectingPointerId);}catch{} selectingPointerId=null;}});

  // Touch fallback (iOS Safari)
  boardEl.addEventListener('touchstart',(e)=>{
    if(!e.touches || e.touches.length===0) return; const t=e.touches[0]; e.preventDefault();
    const i=indexFromPoint(t.clientX,t.clientY); if(i>=0){ if(targeting){ applyTargeting(i); return;} const cell=grid[i]; if(!selecting && cell && cell.power){ if(cell.power==='row' || cell.power==='col'){ useSelfPower(i); return;} enterTargeting(cell.power,i); return;} startSelect(i); }
  }, {passive:false});
  boardEl.addEventListener('touchmove',(e)=>{
    if(!e.touches || e.touches.length===0) return; const t=e.touches[0]; e.preventDefault(); if(!selecting) return; const i=indexFromPoint(t.clientX,t.clientY); if(i>=0) extendTo(i);
  }, {passive:false});
  boardEl.addEventListener('touchend',()=>{ if(selecting) finishSelect(); });

  // Boosters
  function enterTargeting(type,from){ targeting={type,from}; boardEl.classList.add('targeting'); toast(type==='breaker'?(currentLang==='es'?'Toca una pieza para romper':'Tap a tile to break'): (currentLang==='es'?'Elige objetivo':'Choose a target')); }

  function explodeAffected(affected, from){
    affected.forEach(j=>{ const el=boardEl.querySelector(`.tile[data-i='${j}']`); if(el) el.classList.add('explode'); });
    setTimeout(()=>{
      const colorCount={yellow:0,green:0,blue:0,purple:0,red:0};
      affected.forEach(j=>{ const t=grid[j]; if(t && !t.obstacle && t.colorKey && colorCount[t.colorKey]!=null) colorCount[t.colorKey]++; grid[j]=null; });
      if(grid[from]) grid[from]=null; // remove booster tile to allow gravity/refill
      goals.yellow=Math.max(0,goals.yellow-(colorCount.yellow||0)); goals.green=Math.max(0,goals.green-(colorCount.green||0)); goals.blue=Math.max(0,goals.blue-(colorCount.blue||0)); goals.purple=Math.max(0,(goals.purple||0)-(colorCount.purple||0)); goals.red=Math.max(0,(goals.red||0)-(colorCount.red||0));
      recountDynamicObjectives(); updateGoalsUI();
      const movesMap=applyGravity(); refill(); processFireAfterMove(); scheduleHint(); refreshDebugOverlay();
      const px=cellSizePx(); Object.entries(movesMap).forEach(([to,d])=>{ const el=boardEl.querySelector(`.tile[data-i='${to}']`); if(el) el.style.setProperty('--fall',`${-d*px}px`); });
      requestAnimationFrame(()=>{ Object.keys(movesMap).forEach(to=>{ const el=boardEl.querySelector(`.tile[data-i='${to}']`); if(el) el.style.setProperty('--fall','0px'); }); });
      spendMove(); if(goalsComplete()){ toast(STRINGS[currentLang].objectivesDone); spawnConfetti(); nextLevel(); return; } if(moves===0){ showLoseModal(); }
    },260);
  }

  function useSelfPower(from){
    const t=grid[from]; if(!t || !t.power) return;
    const affected=new Set();
    if(t.power==='row'){ const [r]=rc(from); for(let cc=0;cc<COLS;cc++) affected.add(idx(r,cc)); }
    else if(t.power==='col'){ const [,c]=rc(from); for(let rr=0;rr<ROWS;rr++) affected.add(idx(rr,c)); }
    else return; // only row/col here
    explodeAffected(affected, from);
  }
  function applyTargeting(target){
    if(!targeting) return; const {type,from,source}=targeting; const affected=new Set();
    if(from!=null && target===from){ toast(currentLang==='es'?'Elige otra pieza':'Pick a different tile'); return; }
    if(type==='breaker'){ affected.add(target); }
    else if(type==='row'){ const [r]=rc(target); for(let cc=0;cc<COLS;cc++) affected.add(idx(r,cc)); }
    else if(type==='col'){ const [,c]=rc(target); for(let rr=0;rr<ROWS;rr++) affected.add(idx(rr,c)); }
    else if(type==='rainbow'){ affected.add(target); }
    explodeAffected(affected, from); if(source==='inventory'){ if(inventory[type]>0){ inventory[type]--; updateInventoryUI(); } } targeting=null; boardEl.classList.remove('targeting'); }

  // Debug menu + buttons
  if(document.getElementById('debugBtn')){ debugBtn.addEventListener('click',(e)=>{e.stopPropagation(); debugMenu.classList.toggle('show');}); document.addEventListener('click',(e)=>{ if(!debugMenu.contains(e.target) && e.target!==debugBtn){ debugMenu.classList.remove('show'); }}); }
  if(debugToggleOverlayBtn){ debugToggleOverlayBtn.addEventListener('click',()=>{ debugMode=!debugMode; debugToggleOverlayBtn.classList.toggle('primary',debugMode); refreshDebugOverlay(); }); }
  const wordDebugChk=document.getElementById('wordDebugChk');
  if(wordDebugChk){ wordDebugChk.addEventListener('change', ()=>{ verboseWordDebug=wordDebugChk.checked; }); }
  // Inventory buttons
  document.querySelectorAll('#inventory .inv-btn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const type=btn.getAttribute('data-type'); if(!type) return; if((inventory[type]||0)<=0){ toast('No uses left'); return; }
      targeting={type, from:null, source:'inventory'}; boardEl.classList.add('targeting');
      const msg = type==='breaker' ? (currentLang==='es'?'Toca una pieza para romper':'Tap a tile to break')
        : type==='row' ? (currentLang==='es'?'Toca una fila':'Tap a row')
        : type==='col' ? (currentLang==='es'?'Toca una columna':'Tap a column')
        : (currentLang==='es'?'Toca una pieza':'Tap a tile');
      toast(msg);
    });
  });
  if(shuffleBtn){ shuffleBtn.addEventListener('click', ()=>{ const letters=grid.map(cell=>cell && !cell.obstacle ? cell.letter : null).filter(Boolean); for(let i=letters.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [letters[i],letters[j]]=[letters[j],letters[i]]; } let k=0; grid.forEach(cell=>{ if(cell && !cell.obstacle) cell.letter=letters[k++]; }); render(); toast(STRINGS[currentLang].shuffled); scheduleHint(); refreshDebugOverlay(); }); }
  if(endTurnBtn){ endTurnBtn.addEventListener('click', ()=>{ spendMove(); if(moves===0){ toast(STRINGS[currentLang].outOfMoves); nextLevel(); } else { toast(STRINGS[currentLang].turnEnded); } }); }
  const winNowBtn=document.getElementById('winNowBtn');
  if(winNowBtn){ winNowBtn.addEventListener('click', ()=>{ Object.keys(goals).forEach(k=>goals[k]=0); updateGoalsUI(); toast(STRINGS[currentLang].objectivesDone); spawnConfetti(); nextLevel(); }); }
  

  // Tutorial
  function maybeShowTutorial(){ try{ if(localStorage.getItem('lexica_tutorial_shown')) return; }catch(e){} tutorialEl.hidden=false; }
  if(closeTutorialBtn){ closeTutorialBtn.addEventListener('click', ()=>{ tutorialEl.hidden=true; try{ localStorage.setItem('lexica_tutorial_shown','1'); }catch(e){} }); }
  if(tutorialEl && tutorialEl.hasAttribute('data-backdrop')){ tutorialEl.addEventListener('click', (e)=>{ if(e.target===tutorialEl){ tutorialEl.hidden=true; try{ localStorage.setItem('lexica_tutorial_shown','1'); }catch(_){} } }); }

  // Lose modal + confetti
  function showLoseModal(){
    let m=document.getElementById('loseModal'); if(!m){
      m=document.createElement('div'); m.id='loseModal'; m.className='modal'; m.innerHTML=`<div class="modal-panel" style="text-align:center"><h3 id="loseTitle">You lost</h3><div style="margin:8px 0 14px;opacity:.8">${' '}</div><button id="btnRestart" class="debug-badge" style="background:#ef4444">Restart</button></div>`; document.body.appendChild(m);
      m.addEventListener('click',(e)=>{ if(e.target===m) m.hidden=true; });
      document.getElementById('btnRestart').addEventListener('click',()=>{ m.hidden=true; restartLevel(); });
    }
    const s=STRINGS[currentLang]||STRINGS.en; document.getElementById('loseTitle').textContent=(currentLang==='es'?'Perdiste':'You lost'); m.hidden=false;
  }
  function restartLevel(){ moves=20; movesEl.textContent=moves; makeEmpty(); if(!loadLevelFromData(level)){ placeInitial(); } render(); scheduleHint(); refreshDebugOverlay(); updateGoalsUI(); }
  function spawnConfetti(){
    const container=document.createElement('div'); container.style.cssText='position:fixed;inset:0;pointer-events:none;overflow:hidden;z-index:50'; document.body.appendChild(container);
    const colors=['#f87171','#60a5fa','#34d399','#fbbf24','#a78bfa']; const n=80;
    for(let i=0;i<n;i++){ const s=document.createElement('span'); s.textContent='üéâ'; s.style.cssText=`position:absolute;left:${Math.random()*100}% ;top:-10%;font-size:${12+Math.random()*18}px;`; container.appendChild(s); const dx=(-30+Math.random()*60); const dy=110+Math.random()*40; s.animate([{transform:`translate(0,0) rotate(0deg)`},{transform:`translate(${dx}vw,${dy}vh) rotate(${Math.random()*720-360}deg)`}],{duration:1200+Math.random()*800, easing:'cubic-bezier(.2,.8,.2,1)'}).onfinish=()=>{ s.remove(); if(container.childElementCount===0) container.remove(); }; }
  }

  // Level loader (from level_data)
  function colorFromKey(key){ if(COLOR_HEX[key]) return COLOR_HEX[key]; return '#fcd34d'; }
  async function loadLevelFromData(lvl, loopIfMissing){
    const path=relUrl(`level_data/level_${lvl}.json`);
    try{
      if(IS_FILE){
        console.warn('file:// detected ‚Äî trying embedded level_'+lvl);
        const el=document.getElementById('embedded_level_'+lvl);
        if(!el) return false;
        const data=JSON.parse(el.textContent||'{}');
        return applyLevelData(data);
      }
      const r=await fetch(path,{cache:'no-store'});
      if(!r.ok){ if(loopIfMissing) return false; else return false; }
      const data=await r.json();
      return applyLevelData(data);
    }catch(e){ console.warn('loadLevelFromData failed', e); return false; }
  }
  function applyLevelData(data){
    // Size
    COLS=Number(data.cols)||COLS; ROWS=Number(data.rows)||ROWS;
    tilesEl.style.setProperty('--cols',COLS);
    tilesEl.style.setProperty('--rows',ROWS);
    ensureBoardSize();
    // Objectives (include red and purple if present)
    goals={
      yellow: (data.objectives&&data.objectives.yellow)||0,
      green:  (data.objectives&&data.objectives.green)||0,
      blue:   (data.objectives&&data.objectives.blue)||0,
      purple: (data.objectives&&data.objectives.purple)||0,
      red:    (data.objectives&&data.objectives.red)||0,
      ice:    (data.objectives&&data.objectives.ice)||0,
      fire:   (data.objectives&&data.objectives.fire)||0
    };
    updateGoalsUI();
    // Weights
    if(data.letterWeights) setLetterWeights(data.letterWeights);
    if(data.colorWeights) setColorWeights(data.colorWeights);
    // Grid
    grid=Array.from({length:ROWS*COLS},(_,i)=>{
      const cell=data.grid && data.grid[i]; if(!cell) return null;
      if(cell.type==='letter'){
        let letter=String(cell.letter||'');
        let colorKey=cell.color||'yellow';
        // placeholders: empty letter => random; color 'random' => weighted random
        if(!letter){ letter=randLetter(); }
        if(colorKey==='random'){ const c=pickColor(); colorKey=c.key; }
        return {letter:letter.toUpperCase(), colorKey, color:colorFromKey(colorKey), obstacle:null, frozen:false, power:null};
      } else if(cell.type==='ice'){
        return {letter:null,colorKey:null,color:'#b6e0ff',obstacle:'ice',layers:Math.max(1,Number(cell.layers)||1),frozen:false,power:null};
      } else if(cell.type==='stone'){
        return {letter:null,colorKey:null,color:'#bfc4cc',obstacle:'stone',frozen:false,power:null};
      } else if(cell.type==='fire'){
        return {letter:null,colorKey:null,color:'#ffaf87',obstacle:'fire',stage:Number(cell.stage)||1,frozen:false,power:null};
      } else return null;
    });
    // Fill empty with letters
    for(let i=0;i<grid.length;i++){
      if(grid[i]==null) { grid[i]=newTile(); continue; }
      const t=grid[i]; if(t && !t.obstacle){
        if(!t.letter){ t.letter=randLetter(); }
        if(!t.colorKey || t.colorKey==='random'){ const cc=pickColor(); t.colorKey=cc.key; t.color=colorFromKey(t.colorKey); }
      }
    }
    return true;
  }

  // Icons from repo sprites
  function setBoosterIcons(urlBreaker, urlRow, urlCol, urlRainbow){ const root=document.documentElement; if(urlBreaker) root.style.setProperty('--img-breaker', `url(${urlBreaker})`); if(urlRow) root.style.setProperty('--img-row', `url(${urlRow})`); if(urlCol) root.style.setProperty('--img-col', `url(${urlCol})`); if(urlRainbow) root.style.setProperty('--img-rainbow', `url(${urlRainbow})`); }

  async function init(){
    moves=20; movesEl.textContent=moves;
    ensureBoardSize();
    inventory={breaker:5,row:5,col:5,rainbow:5}; updateInventoryUI();
    makeEmpty(); const ok=await loadLevelFromData(1,false); if(!ok){ setProceduralGoals(60); placeInitial(); } render(); updateGoalsUI(); applyLanguageToUI(); maybeShowTutorial();
    // load dictionaries for current language early (non-blocking for UI)
    loadDictionary(currentLang).then(function(){ scheduleHint(); if(debugMode) refreshDebugOverlay(); });
    // No sprites: boosters use emojis now
    window.addEventListener('resize', ()=>{ ensureBoardSize(); render(); });
    setTimeout(()=>{ ensureBoardSize(); render(); }, 0);
    // set selector value + listener
    const langSelect=document.getElementById('langSelect');
    if(langSelect){ langSelect.value=currentLang; langSelect.addEventListener('change', async function(){ currentLang=langSelect.value; try{ localStorage.setItem('lexica_lang', currentLang); }catch(_){ } applyLanguageToUI(); await loadDictionary(currentLang); scheduleHint(); if(debugMode) refreshDebugOverlay(); }); }
  }
  init();
})();
</script>
</body>
</html>
