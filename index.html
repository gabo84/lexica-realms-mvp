<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Lexica Realms - MVP</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' ry='12' fill='%23ffffff'/%3E%3Ctext x='50%25' y='54%25' dominant-baseline='middle' text-anchor='middle' font-size='44'%3Eüî§%3C/text%3E%3C/svg%3E">
<style>
  :root{
    --blue:#77b7ff; --lilac:#c3a5ff; --shadow: rgba(0,0,0,0.12); --ink:#111;
    --img-breaker: "";   /* url(sprites/hammer.png) */
    --img-row: "";       /* url(sprites/row_breaker.png) */
    --img-col: "";       /* url(sprites/column_breaker.png) */
    --img-rainbow: "";   /* url(sprites/wildcard.png) */
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent;touch-action:none;}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    background:linear-gradient(180deg,#f6fbff,#f9f9ff);
    color:var(--ink);
    padding-top: env(safe-area-inset-top); padding-bottom: env(safe-area-inset-bottom);
  }
  #app{width:100vw;height:calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));max-width:480px;margin:0 auto;display:flex;flex-direction:column;}

  header{
    width:100%; padding:10px 16px; display:flex; justify-content:space-between; align-items:center;
    background:#e9eaed; border-bottom-left-radius:22px; border-bottom-right-radius:22px;
    box-shadow:0 2px 10px var(--shadow); position:sticky; top:0; z-index:5;
  }
  .debug-badge{background:#ff8f2e;color:#fff;font-weight:900;border:none;border-radius:10px;padding:8px 12px;box-shadow:0 2px 6px var(--shadow);} 
  .goals-bar{display:flex;align-items:center;gap:18px;background:#a87657;color:#2b1b12;padding:10px 16px;border-radius:16px;margin-left:10px;}
  .goal-item{display:flex;flex-direction:column;align-items:center;gap:6px;}
  .goal-swatch{width:34px;height:34px;border-radius:6px;box-shadow:inset 0 2px 0 rgba(255,255,255,.5), inset 0 -2px 0 rgba(0,0,0,.15);}
  .goal-num{font-weight:900;}
  .stat{display:flex;gap:10px;align-items:center;font-weight:700;}
  .pill{background:#fff;padding:8px 12px;border-radius:999px;box-shadow:0 2px 6px var(--shadow);font-weight:800;}

  .debug-wrap{position:relative;}
  .debug-menu{position:absolute; right:0; top:44px; background:#fff; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.2); padding:8px; display:none; z-index:10; min-width:200px;}
  .debug-menu.show{display:block;}
  .debug-menu .menu-item{display:block; width:100%; text-align:left; border:none; background:#fff; padding:10px 12px; border-radius:10px; font-weight:700; box-shadow:0 2px 6px var(--shadow); margin:6px 0;}
  .debug-menu .menu-item.primary{background:var(--blue); color:#fff;}

  /* Board */
  #board{width:92vw; max-width:420px; aspect-ratio:8/10; margin:12px auto; padding:12px; background:#f4f6f9; border-radius:14px; box-shadow:0 10px 30px var(--shadow); position:relative;}
  #tiles{position:absolute; inset:0; display:grid; grid-template-columns:repeat(var(--cols,8),1fr); grid-template-rows:repeat(var(--rows,10),1fr); gap:12px;}

  /* Tiles */
  .tile{
    display:flex; align-items:center; justify-content:center;
    font-size: clamp(18px,7vw,42px); font-weight:900; color: var(--ink);
    user-select:none; position:relative;
    background:#eee; /* override inline per tile color */
    box-shadow: 0 6px 14px rgba(0,0,0,.18), inset 0 1px 0 rgba(255,255,255,.6), inset 0 -3px 0 rgba(0,0,0,.18);
    border-radius: 8px;
    transition: transform 260ms cubic-bezier(0.22, 1, 0.36, 1), box-shadow 140ms ease, filter 180ms ease; will-change: transform; 
    --ty: 0px; --sc: 1;
    transform: translateY(calc(var(--ty) + var(--fall, 0px))) scale(var(--sc));
  }
  .tile.selected{
    --sc: .95;
    box-shadow:
      0 0 0 3px #0aa inset,
      0 0 0 3px rgba(0,0,0,.2),
      0 10px 22px rgba(0,0,0,.22),
      inset 0 2px 0 rgba(255,255,255,.8),
      inset 0 -4px 0 rgba(0,0,0,.3);
  }
  .tile.glow{ animation: glow 800ms ease-out; }
  @keyframes glow{ 0%{ filter: drop-shadow(0 0 0 rgba(255,255,255,0)); } 50%{ filter: drop-shadow(0 0 12px rgba(255,255,255,1)); } 100%{ filter: drop-shadow(0 0 0 rgba(255,255,255,0)); } }

  .tile.explode{ animation: explode .22s ease-out forwards; }
  @keyframes explode{ 0%{ transform: translateY(calc(var(--ty) + var(--fall, 0px))) scale(1); opacity:1; } 100%{ transform: translateY(calc(var(--ty) - 12px)) scale(.6); opacity:0; filter: blur(1px); } }
  .tile.fall{ animation: fall .18s ease-out; }
  @keyframes fall{ 0%{ transform: translateY(calc(var(--ty) - 14px)) scale(1); } 100%{ transform: translateY(calc(var(--ty) + var(--fall, 0px))) scale(1); } }

  .tile.obstacle-stone{background:#bfc4cc;color:transparent;}
  .tile.obstacle-frozen{background:linear-gradient(135deg,#c9f2ff,#b6e0ff);} 
  .tile.obstacle-ice{background:linear-gradient(135deg,#c9f2ff,#b6e0ff);} 
  .tile.obstacle-bomb{background:radial-gradient(circle at 50% 40%, #444, #222); color:#fff; font-size: 24px;}
  .tile .badge{position:absolute;bottom:6px;right:6px;font-size:12px;font-weight:800;background:#111;color:#fff;padding:2px 6px;border-radius:999px;letter-spacing:.2px;opacity:.9;}
  .tile .ord{position:absolute; top:6px; left:6px; width:20px; height:20px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:12px; font-weight:800; background:#111; color:#fff; box-shadow:0 1px 3px rgba(0,0,0,.2);} 
  /* Large emoji when tile is a booster */
  .tile.power-emoji{ font-size: clamp(34px, 9.5vw, 68px); line-height: 1; }
  .tile .corner-ice{ position:absolute; top:6px; left:6px; font-size:16px; filter: drop-shadow(0 1px 1px rgba(0,0,0,.25)); }

  .tile.hint{ box-shadow: 0 0 0 3px #000 inset, 0 6px 18px rgba(0,0,0,.35); }
  .tile.debug{ outline:3px dashed rgba(255,0,110,.6); outline-offset:-3px; }

  .tile.breaker::after{content:\"\"; position:absolute; top:6px; left:6px; width:20px; height:20px; background-size:cover; background-image: var(--img-breaker);}
  .tile.breaker:not([style*=\"--img-breaker\"])::after{content:\"üî®\"; background-image:none; width:auto; height:auto; font-size:16px;}
  .tile.row::after{content:\"\"; position:absolute; top:6px; left:6px; width:20px; height:20px; background-size:cover; background-image: var(--img-row);} 
  .tile.row:not([style*=\"--img-row\"])::after{content:\"‚û°Ô∏è\"; background-image:none; width:auto; height:auto; font-size:16px;}
  .tile.col::after{content:\"\"; position:absolute; top:6px; left:6px; width:20px; height:20px; background-size:cover; background-image: var(--img-col);} 
  .tile.col:not([style*=\"--img-col\"])::after{content:\"‚¨áÔ∏è\"; background-image:none; width:auto; height:auto; font-size:16px;}
  .tile.rainbow::after{content:\"\"; position:absolute; top:6px; left:6px; width:20px; height:20px; background-size:cover; background-image: var(--img-rainbow);} 
  .tile.rainbow:not([style*=\"--img-rainbow\"])::after{content:\"üåà\"; background-image:none; width:auto; height:auto; font-size:16px;}
  .tile.rainbow{background:conic-gradient(from 0deg,#f9c,#9cf,#9fc,#fc9,#f9c);} 

  #board.targeting .tile{ cursor: crosshair; }

  #bottom{width:100%; padding:14px 16px; display:flex; align-items:center; justify-content:center; background:#e9eaed; box-shadow:0 -2px 10px var(--shadow); position:sticky; bottom:0; z-index:5;}
  #current-word{font-weight:900; letter-spacing:4px; font-size:20px; background:#fff; padding:10px 14px; border-radius:12px; box-shadow:0 2px 6px var(--shadow); min-width:200px; text-align:center;}

  #toast{position:fixed;top:10px;left:50%;transform:translateX(-50%);background:#111;color:#fff;padding:10px 14px;border-radius:10px;box-shadow:0 8px 20px rgba(0,0,0,.2);opacity:0;pointer-events:none;transition:opacity .2s ease;z-index:9;}

  .modal{position:fixed;inset:0;background:rgba(0,0,0,.5);display:flex;align-items:center;justify-content:center;z-index:20;}
  .modal[hidden]{display:none !important;}
  .modal-panel{background:#fff;border-radius:16px;max-width:420px;width:90vw;padding:18px;box-shadow:0 20px 50px rgba(0,0,0,.3);} 
  .modal h3{margin:0 0 8px 0;}
  .modal ol{margin:0 0 8px 18px;}
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="stat">
      <span class="pill"><span id="lblMoves">Moves</span> <span id="moves">20</span></span>
      <div class="goals-bar">
        <div class="goal-item"><div class="goal-swatch" style="background:#60a5fa"></div><div class="goal-num" id="goalB">20</div></div>
        <div class="goal-item"><div class="goal-swatch" style="background:#fcd34d"></div><div class="goal-num" id="goalY">20</div></div>
        <div class="goal-item"><div class="goal-swatch" style="background:#34d399"></div><div class="goal-num" id="goalG">20</div></div>
        <div class="goal-item"><div class="goal-swatch" style="display:flex;align-items:center;justify-content:center;background:#b6e0ff;color:#114;font-size:18px;">üßä</div><div class="goal-num" id="goalIce">6</div></div>
      </div>
    </div>
    <div class="debug-wrap">
      <button class="debug-badge" id="debugBtn" title="Open debug menu" aria-label="Debug">ü™≤</button>
      <div class="debug-menu" id="debugMenu">
        <div style="padding:6px 8px 2px 8px;font-weight:800;opacity:.8;">Idioma / Language</div>
        <select id="langSelect" class="menu-item" style="box-shadow:none;border:1px solid #ddd;">
          <option value="en">English</option>
          <option value="es">Espa√±ol</option>
        </select>
        <button class="menu-item" id="debugToggleOverlay">Toggle overlay</button>
        <button class="menu-item" id="shuffleBtn">Shuffle</button>
        <button class="menu-item" id="endTurnBtn">End Turn</button>
      </div>
    </div>
  </header>

  <div id="board" aria-label="Game board"><div id="tiles"></div></div>

  <div id="bottom"><div id="current-word">____</div></div>
</div>
<div id="toast"></div>

<div id="tutorial" class="modal" data-backdrop hidden>
  <div class="modal-panel">
    <h3>How to play</h3>
    <ol>
      <li id="tut1">Press and drag across adjacent letters (diagonals ok) to form a word.</li>
      <li id="tut2">Release to submit. If valid, tiles are removed and colors count toward goals.</li>
      <li id="tut3">Words of 4/5/6/7+ grant boosters: Breaker / Row / Column / Rainbow.</li>
      <li id="tut4">Use a booster by tapping its tile, then tap a target.</li>
    </ol>
    <button id="closeTutorial" class="debug-badge" style="background:#60a5fa">Got it</button>
  </div>
</div>

<footer style="max-width:1080px;margin:16px auto 28px;padding:12px 16px;color:#333;font-size:14px;line-height:1.5;">
  <strong>Boosters (actualizados):</strong>
  <ul style="margin:8px 0 0 18px; padding:0;">
    <li><strong>4 letras ‚Üí üî® Block breaker:</strong> toca el booster y luego una ficha para romper solo esa pieza.</li>
    <li><strong>5 letras ‚Üí ‚û°Ô∏è Row breaker:</strong> toca el booster y luego una ficha para romper toda la fila.</li>
    <li><strong>6 letras ‚Üí ‚¨áÔ∏è Column breaker:</strong> toca el booster y luego una ficha para romper toda la columna.</li>
    <li><strong>7+ letras ‚Üí üåà Rainbow (comod√≠n):</strong> √∫salo dentro de una palabra; puede reemplazar cualquier letra/color.</li>
  </ul>
</footer>

<script>
(function(){
  const COLS=8, ROWS=10;

  // === Language + remote dictionaries ===
  let currentLang = (()=>{ try{ return localStorage.getItem('lexica_lang') || 'en'; }catch(_){ return 'en'; } })();

  const STRINGS = {
    en:{moves:'Moves',tut1:'Press and drag across adjacent letters (diagonals ok) to form a word.',tut2:'Release to submit. If valid, tiles are removed and colors count toward goals.',tut3:'Words of 4/5/6/7+ grant boosters: Breaker / Row / Column / Rainbow.',tut4:'Use a booster by tapping its tile, then tap a target.',shuffled:'Shuffled',turnEnded:'Turn ended',outOfMoves:'Out of moves',lvlUp:'Level up',notValid:'Not a valid word',powerCreated:'Power-up created!',objectivesDone:'Objectives complete!'},
    es:{moves:'Movimientos',tut1:'Mant√©n presionado y arrastra por letras adyacentes (diagonales tambi√©n) para formar una palabra.',tut2:'Suelta para enviar. Si es v√°lida, se eliminan las fichas y sus colores cuentan al objetivo.',tut3:'Palabras de 4/5/6/7+ otorgan poderes: Rompe-bloque / Rompe-fila / Rompe-columna / Comod√≠n.',tut4:'Usa un poder tocando su ficha y luego el objetivo.',shuffled:'Mezclado',turnEnded:'Turno finalizado',outOfMoves:'Sin movimientos',lvlUp:'Nivel superado',notValid:'Palabra inv√°lida',powerCreated:'¬°Poder creado!',objectivesDone:'¬°Objetivos completos!'}
  };

  const DICT_URL_EN = 'https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt';
  const DICT_URL_ES = 'https://raw.githubusercontent.com/words/an-array-of-spanish-words/master/index.json';
  const dictCache={en:null, es:null}, prefCache={en:null, es:null};
  async function loadDictionary(lang){
    if(dictCache[lang] && prefCache[lang]) return {dict:dictCache[lang], pref:prefCache[lang]};
    try{
      if(lang==='en'){
        const r=await fetch(DICT_URL_EN, {mode:'cors'}); const txt=await r.text();
        const words=txt.split(/\\r?\\n/).filter(w=>w&&w.length>=3).map(w=>w.toUpperCase());
        const dict=new Set(words), pref=new Set(); for(const w of words){ for(let i=1;i<=w.length;i++) pref.add(w.slice(0,i)); }
        dictCache.en=dict; prefCache.en=pref; return {dict,pref};
      }else{
        const r=await fetch(DICT_URL_ES, {mode:'cors'}); const arr=await r.json();
        const words=arr.filter(w=>w&&w.length>=3).map(w=>String(w).toUpperCase());
        const dict=new Set(words), pref=new Set(); for(const w of words){ for(let i=1;i<=w.length;i++) pref.add(w.slice(0,i)); }
        dictCache.es=dict; prefCache.es=pref; return {dict,pref};
      }
    }catch(e){
      console.warn('Dictionary load failed', lang, e);
      // Fallback to local minimal sets (built below)
      return {dict:dictionary, pref:prefixes};
    }
  }

  function applyLanguageToUI(){
    const s=STRINGS[currentLang]||STRINGS.en;
    const lm=document.getElementById('lblMoves'); if(lm) lm.textContent=s.moves;
    const t1=document.getElementById('tut1'); if(t1) t1.textContent=s.tut1;
    const t2=document.getElementById('tut2'); if(t2) t2.textContent=s.tut2;
    const t3=document.getElementById('tut3'); if(t3) t3.textContent=s.tut3;
    const t4=document.getElementById('tut4'); if(t4) t4.textContent=s.tut4;
  }

  const vowels="AEIOU";
  const lettersBag=[..."EEEEEEEEEEEEAAAAAAAIIIIIIIOOOOOONNNNNNRRRRRRTTTTTTLLLLSSSSUUUUDDDDGGGBBCCMMPPFFHHVVWWYKJXQZ"];

  const COLOR_WEIGHTS=[{key:'yellow',weight:40,color:'#fcd34d'},{key:'green',weight:30,color:'#34d399'},{key:'blue',weight:20,color:'#60a5fa'},{key:'purple',weight:10,color:'#a78bfa'}];
  function pickColor(){const total=COLOR_WEIGHTS.reduce((s,o)=>s+o.weight,0);let r=Math.random()*total;for(const o of COLOR_WEIGHTS){if((r-=o.weight)<=0) return {key:o.key,color:o.color}}return {key:'yellow',color:'#fcd34d'}}

  const hexToRgb=h=>{const x=h.replace('#','');const n=parseInt(x.length===3?x.split('').map(c=>c+c).join(''):x,16);return{r:(n>>16)&255,g:(n>>8)&255,b:n&255}};
  const relL=({r,g,b})=>{const s=[r,g,b].map(v=>{v/=255;return v<=.03928?v/12.92:Math.pow((v+.055)/1.055,2.4)});return .2126*s[0]+.7152*s[1]+.0722*s[2]};
  const readable=bg=>relL(hexToRgb(bg))>0.5?'#111':'#fff';
  const tint=(hex,amt)=>{const {r,g,b}=hexToRgb(hex);const m=c=>Math.min(255,Math.round(c+(255-c)*amt));const rr=m(r),gg=m(g),bb=m(b);return '#'+[rr,gg,bb].map(v=>v.toString(16).padStart(2,'0')).join('')};

  // small local fallback dic
  const wordList=["ABLE","ABOUT","APPLE","POOL","HOUSE","LIGHT","GREEN","BLUE","YELLOW","WORLD","STONE","FROZEN","LEVEL","MOVE","GOAL","ROOM","ROAD","WATER","PLAY","WORD","WORDS","BOOK","BOOKS"];
  const dictionary=new Set(wordList.map(w=>w.toUpperCase()));
  const prefixes=new Set(); for(const w of wordList){const u=w.toUpperCase(); for(let i=1;i<=u.length;i++) prefixes.add(u.slice(0,i));}

  const boardEl=document.getElementById('board');
  const tilesEl=document.getElementById('tiles');
  const movesEl=document.getElementById('moves');
  const toastEl=document.getElementById('toast');
  const debugBtn=document.getElementById('debugBtn');
  const debugMenu=document.getElementById('debugMenu');
  const debugToggleOverlayBtn=document.getElementById('debugToggleOverlay');
  const shuffleBtn=document.getElementById('shuffleBtn');
  const endTurnBtn=document.getElementById('endTurnBtn');
  const tutorialEl=document.getElementById('tutorial');
  const closeTutorialBtn=document.getElementById('closeTutorial');

  let level=1, moves=20, grid=[], selection=[], selecting=false, selectingPointerId=null;
  let hintTimer=null; const HINT_DELAY_MS=5000; let currentHint=null;
  let debugMode=false, targeting=null, submitting=false;

  tilesEl.style.setProperty('--cols',COLS);
  tilesEl.style.setProperty('--rows',ROWS);
  boardEl.style.aspectRatio=`${COLS}/${ROWS}`;

  function ensureBoardSize(){
    const rect=boardEl.getBoundingClientRect();
    if(rect.height<10){
      const w=boardEl.clientWidth || boardEl.getBoundingClientRect().width || 320;
      boardEl.style.height = Math.round(w * (ROWS/COLS)) + 'px';
    }
  }

  const cellSizePx=()=>{
    const h=boardEl.getBoundingClientRect().height;
    if(h>0) return h/ROWS;
    const w=boardEl.getBoundingClientRect().width;
    return (w*(ROWS/COLS))/ROWS;
  };
  const idx=(r,c)=>r*COLS+c;
  const rc=i=>[Math.floor(i/COLS),i%COLS];
  const inBounds=(r,c)=>r>=0&&c>=0&&r<ROWS&&c<COLS;

  const randLetter=()=>{const pick=lettersBag[Math.floor(Math.random()*lettersBag.length)];return Math.random()<0.12?vowels[Math.floor(Math.random()*vowels.length)]:pick;};
  const newTile=()=>{const col=pickColor();return{letter:randLetter(),colorKey:col.key,color:col.color,obstacle:null,frozen:false,power:null}};

  function placeIceBlockers(){
    // Coordinates are (row, col), 0-indexed as provided
    const coords=[[1,1],[1,6],[4,3],[4,4],[7,1],[7,6]];
    for(const [r,c] of coords){ if(inBounds(r,c)){ const i=idx(r,c); grid[i]={letter:null,colorKey:null,color:'#b6e0ff',obstacle:'ice',frozen:false,power:null}; } }
  }

  function makeEmpty(){grid=Array.from({length:ROWS*COLS},()=>null);}
  function placeInitial(){for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) grid[idx(r,c)]=newTile();}

  function render(){
    tilesEl.innerHTML='';
    const cs=getComputedStyle(tilesEl); const gap=parseFloat(cs.gap)||0; const h=tilesEl.clientHeight; const trackH=(h - (ROWS-1)*gap)/ROWS; const emojiSize=Math.max(18, Math.floor(trackH*0.82));
    grid.forEach((cell,i)=>{
      const div=document.createElement('div'); div.className='tile'; div.dataset.i=i;
      if(cell){
        if(cell.obstacle==='stone'){div.classList.add('obstacle-stone');}
        else if(cell.obstacle==='bomb'){div.classList.add('obstacle-bomb'); div.textContent='üß®';}
        else if(cell.obstacle==='ice'){div.classList.add('obstacle-ice'); const span=document.createElement('span'); span.textContent='üßä'; span.style.fontSize=emojiSize+'px'; div.appendChild(span);}
        else{
          // Background and text color
          const top=tint(cell.color,.22); div.style.background=`linear-gradient(135deg, ${top}, ${cell.color})`;
          div.style.color=readable(cell.color);
          // Frozen overlay
          if(cell.frozen){ div.classList.add('obstacle-frozen'); const ice=document.createElement('span'); ice.className='corner-ice'; ice.textContent='üßä'; div.appendChild(ice); }
          // Booster emoji replaces the letter completely
          if(cell.power){
            const emoji = cell.power==='rainbow'?'üÉè':(cell.power==='breaker'?'üî®':(cell.power==='row'?'‚ÜîÔ∏è':'‚ÜïÔ∏è'));
            const span=document.createElement('span'); span.className='booster-emoji'; span.textContent=emoji; span.style.fontSize=emojiSize+'px'; div.appendChild(span); div.classList.add('power-emoji');
          }else{
            div.textContent=cell.letter;
          }
        }
      }else div.style.visibility='hidden';
      tilesEl.appendChild(div);
    });
  }

  const isAdjacent=(a,b)=>{const[ar,ac]=rc(a),[br,bc]=rc(b);return Math.max(Math.abs(ar-br),Math.abs(ac-bc))===1;}
  const indexFromPoint=(x,y)=>{ const el=document.elementFromPoint(x,y); const tile=el && el.closest ? el.closest('.tile') : null; return tile ? Number(tile.dataset.i) : -1; };

  function getCurrentWord(){ return selection.map(function(i){ return (grid[i] && grid[i].letter) || ''; }).join(''); }
  function updateWordDisplay(){const el=document.getElementById('current-word'); if(!el) return; const w=getCurrentWord(); el.textContent=w ? w : '____';}
  function updateSelClasses(){
    document.querySelectorAll('.tile').forEach(t=>{ t.classList.remove('selected'); const o=t.querySelector('.ord'); if(o) o.remove(); });
    selection.forEach((i,ord)=>{ const el=tilesEl.querySelector(`.tile[data-i='${i}']`); if(el){ el.classList.add('selected'); const s=document.createElement('span'); s.className='ord'; s.textContent=String(ord+1); el.appendChild(s);} });
    updateWordDisplay();
  }
  function clearSelection(){selection=[]; updateSelClasses();}

  function startSelect(i){
    clearTimeout(hintTimer); if(submitting) return; const t=grid[i];
    if(!t || t.obstacle==='stone' || t.obstacle==='bomb' || t.obstacle==='ice' || t.power) return; // power tiles and ice are not letters
    selecting=true; selection=[i]; updateSelClasses();
  }
  function extendTo(i){
    if(!selecting) return; if(i<0) return; const t=grid[i];
    if(!t || t.obstacle==='stone' || t.obstacle==='bomb' || t.obstacle==='ice' || t.power) return; // skip power/ice
    const last=selection[selection.length-1]; if(i===last) return;
    if(selection.length>=2 && i===selection[selection.length-2]){selection.pop(); updateSelClasses(); return;}
    const pos=selection.indexOf(i); if(pos!==-1){selection=selection.slice(0,pos+1); updateSelClasses(); return;}
    if(isAdjacent(last,i)){selection.push(i); updateSelClasses();}
  }
  function finishSelect(){if(!selecting) return; selecting=false; if(selection.length>1 && selection[selection.length-1]===selection[0]){clearSelection(); scheduleHint(); return;} if(selection.length<3){clearSelection(); scheduleHint(); return;} endSelect();}

  async function isValidWordAsync(w){ if(!w||w.length<3) return false; const u=w.toUpperCase(); const {dict}=await loadDictionary(currentLang); return dict.has(u); }

  function toast(msg){toastEl.textContent=msg; toastEl.style.opacity=1; clearTimeout(toastEl._t); toastEl._t=setTimeout(()=>toastEl.style.opacity=0,1200);}
  function shakeBoard(){ boardEl.animate([{transform:'translateX(0)'},{transform:'translateX(-8px)'},{transform:'translateX(8px)'},{transform:'translateX(0)'}],{duration:220}); toast(STRINGS[currentLang].notValid); }

  async function endSelect(){ if(submitting) return; submitting=true; const w=getCurrentWord(); const ok=await isValidWordAsync(w); if(!ok){shakeBoard(); clearSelection(); scheduleHint(); submitting=false; return;} resolveWord(w); submitting=false; }

  // Goals by color
  let goals={yellow:20, green:20, blue:20, ice:6};
  const goalYEl=document.getElementById('goalY'); const goalGEl=document.getElementById('goalG'); const goalBEl=document.getElementById('goalB'); const goalIceEl=document.getElementById('goalIce');
  const updateGoalsUI=()=>{goalYEl.textContent=goals.yellow; goalGEl.textContent=goals.green; goalBEl.textContent=goals.blue; if(goalIceEl) goalIceEl.textContent=(goals.ice!=null?goals.ice:0);};
  const goalsComplete=()=> goals.yellow<=0 && goals.green<=0 && goals.blue<=0 && ((goals.ice!=null?goals.ice:0)<=0);

  function spendMove(){ moves=Math.max(0,moves-1); movesEl.textContent=moves; }
  function nextLevel(){ level++; moves=20; movesEl.textContent=moves; goals={yellow:20,green:20,blue:20,ice:6}; updateGoalsUI(); makeEmpty(); placeInitial(); placeIceBlockers(); render(); refreshDebugOverlay(); toast(STRINGS[currentLang].lvlUp); }

  function resolveWord(word){
    const len=selection.length; let newPower=null;
    if(len>=7) newPower='rainbow'; else if(len===6) newPower='col'; else if(len===5) newPower='row'; else if(len===4) newPower='breaker';
    const toRemove=new Set(selection);
    const colorCount={yellow:0,green:0,blue:0};
    selection.forEach(i=>{const t=grid[i]; if(t && t.frozen){ t.frozen=false; toRemove.delete(i); }});
    const bombsToExplode=new Set();
    // Break adjacent ICE blockers -> convert to fresh letters and count towards ice goal
    const iceToBreak=new Set();
    selection.forEach(i=>{ const [r,c]=rc(i); for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ const nr=r+dr,nc=c+dc; if(dr===0&&dc===0) continue; if(!inBounds(nr,nc)) continue; const j=idx(nr,nc); const cell=grid[j]; if(cell && cell.obstacle==='ice') iceToBreak.add(j); }});
    selection.forEach(i=>{const [r,c]=rc(i); for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0) continue; const nr=r+dr,nc=c+dc; if(!inBounds(nr,nc)) continue; const j=idx(nr,nc); const cell=grid[j]; if(cell && cell.obstacle==='bomb'){ cell.state=(cell.state||0)+1; if(cell.state>=2) bombsToExplode.add(j); } }});
    const stonesToRemove=new Set();
    toRemove.forEach(i=>{const [r,c]=rc(i); for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0) continue; const nr=r+dr,nc=c+dc; if(inBounds(nr,nc)){ const j=idx(nr,nc); if(grid[j] && grid[j].obstacle==='stone') stonesToRemove.add(j); } }});
    toRemove.forEach(i=>{const t=grid[i]; if(t && !t.obstacle && t.colorKey && colorCount[t.colorKey]!=null) colorCount[t.colorKey]++; grid[i]=null;});
    stonesToRemove.forEach(i=>grid[i]=null);
    let iceBrokenCount=0;
    iceToBreak.forEach(j=>{ grid[j]=newTile(); iceBrokenCount++; });
    bombsToExplode.forEach(bi=>{const [r,c]=rc(bi); const affected=new Set([bi]); for(let rr=0; rr<ROWS; rr++) affected.add(idx(rr,c)); for(let cc=0; cc<COLS; cc++) affected.add(idx(r,cc)); affected.forEach(ai=>{const t=grid[ai]; if(t && !t.obstacle && t.colorKey && colorCount[t.colorKey]!=null) colorCount[t.colorKey]++; grid[ai]=null;});});
    if(newPower){
      const last=selection[selection.length-1]; let tIdx=last; if(grid[tIdx]!==null){ var arr=Array.from(toRemove); tIdx = (arr.length>0?arr[0]:last); }
      if(tIdx!=null) grid[tIdx]={letter:'', colorKey:'purple', color:'#a78bfa', obstacle:null, frozen:false, power:newPower};
      toast(STRINGS[currentLang].powerCreated);
    }
    goals.yellow=Math.max(0,goals.yellow-(colorCount.yellow||0)); goals.green=Math.max(0,goals.green-(colorCount.green||0)); goals.blue=Math.max(0,goals.blue-(colorCount.blue||0)); goals.ice=Math.max(0,(goals.ice||0)-iceBrokenCount); updateGoalsUI();
    const movesMap=applyGravity(); refill(); scheduleHint(); refreshDebugOverlay();
    const px=cellSizePx(); Object.entries(movesMap).forEach(([to,d])=>{const el=boardEl.querySelector(`.tile[data-i='${to}']`); if(el) el.style.setProperty('--fall',`${-d*px}px`);}); requestAnimationFrame(()=>{Object.keys(movesMap).forEach(to=>{const el=boardEl.querySelector(`.tile[data-i='${to}']`); if(el) el.style.setProperty('--fall','0px');});});
    clearSelection(); spendMove();
    if(goalsComplete()){ toast(STRINGS[currentLang].objectivesDone); nextLevel(); return; }
    if(moves===0){ toast(STRINGS[currentLang].outOfMoves); nextLevel(); }
  }

  function applyGravity(){ const moves={}; for(let c=0;c<COLS;c++){ let write=ROWS-1; for(let r=ROWS-1;r>=0;r--){ const i=idx(r,c), cell=grid[i]; if(cell){ if(cell.obstacle==='stone' || cell.obstacle==='ice'){ write=r-1; continue; } if(write!==r){ const wi=idx(write,c); grid[wi]=cell; grid[i]=null; moves[wi]=(moves[wi]||0)+(write-r);} write--; } } } return moves; }
  function refill(){ for(let c=0;c<COLS;c++) for(let r=0;r<ROWS;r++){ const i=idx(r,c); if(grid[i]===null) grid[i]=newTile(); } render(); }

  function clearHint(){ currentHint=null; document.querySelectorAll('.tile.hint').forEach(e=>e.classList.remove('hint')); }
  function scheduleHint(){ clearTimeout(hintTimer); hintTimer=setTimeout(()=>{ showAnyHint(); }, HINT_DELAY_MS); }
  function showHintPath(path){ path.forEach(i=>{ const el=boardEl.querySelector(`.tile[data-i='${i}']`); if(el) el.classList.add('hint'); }); }
  async function showAnyHint(){
    clearHint(); const {dict,pref}=await loadDictionary(currentLang);
    const visited=new Array(ROWS*COLS).fill(false); const maxLen=6; let found=null;
    function dfs(path){ if(found) return; var word=path.map(function(i){ return (grid[i]&&grid[i].letter)||''; }).join('').toUpperCase(); if(!pref.has(word)) return; if(word.length>=3 && dict.has(word)){ found=path.slice(); return;} if(path.length===maxLen) return; const last=path[path.length-1]; const _rc=rc(last); const r=_rc[0], c=_rc[1]; for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0) continue; const nr=r+dr,nc=c+dc; if(!inBounds(nr,nc)) continue; const j=idx(nr,nc); if(visited[j]) continue; const cell=grid[j]; if(!cell || cell.obstacle==='stone' || cell.obstacle==='bomb' || cell.obstacle==='ice' || cell.power) continue; visited[j]=true; path.push(j); dfs(path); path.pop(); visited[j]=false; if(found) return; }}
    for(let i=0;i<ROWS*COLS && !found;i++){ const cell=grid[i]; if(!cell || cell.obstacle==='stone' || cell.obstacle==='bomb' || cell.obstacle==='ice' || cell.power) continue; visited[i]=true; dfs([i]); visited[i]=false; }
    if(found){ currentHint=found; showHintPath(found); }
  }

  function clearDebug(){ document.querySelectorAll('.tile.debug').forEach(el=>el.classList.remove('debug')); }
  function drawDebugPaths(list){ clearDebug(); const maxDraw=Math.min(list.length,80); for(let n=0;n<maxDraw;n++){ const {path}=list[n]; path.forEach(i=>{ const el=boardEl.querySelector(`.tile[data-i='${i}']`); if(el) el.classList.add('debug'); }); } }
  async function findAllWordsOnBoard(){
    const {dict,pref}=await loadDictionary(currentLang); const results=[]; const visited=new Array(ROWS*COLS).fill(false); const maxLen=7;
    function dfs(path){ const word=path.map(function(i){ return (grid[i]&&grid[i].letter)||''; }).join('').toUpperCase(); if(!pref.has(word)) return; if(word.length>=3 && dict.has(word)){ results.push({word, path:path.slice()}); if(results.length>200) return; } if(path.length===maxLen) return; const last=path[path.length-1]; const _rc=rc(last); const r=_rc[0], c=_rc[1]; for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0) continue; const nr=r+dr,nc=c+dc; if(!inBounds(nr,nc)) continue; const j=idx(nr,nc); if(visited[j]) continue; const cell=grid[j]; if(!cell || cell.obstacle==='stone' || cell.obstacle==='bomb' || cell.obstacle==='ice' || cell.power) continue; visited[j]=true; path.push(j); dfs(path); path.pop(); visited[j]=false; if(results.length>200) return; } }
    for(let i=0;i<ROWS*COLS;i++){ const cell=grid[i]; if(!cell || cell.obstacle==='stone' || cell.obstacle==='bomb' || cell.obstacle==='ice' || cell.power) continue; visited[i]=true; dfs([i]); visited[i]=false; if(results.length>200) break; }
    return results;
  }
  async function refreshDebugOverlay(){ if(!debugMode){ clearDebug(); return; } const list=await findAllWordsOnBoard(); drawDebugPaths(list); toast(list.length+' words'); }

  // Events
  boardEl.addEventListener('pointerdown',(e)=>{const i=indexFromPoint(e.clientX,e.clientY); if(i>=0){ if(targeting){ applyTargeting(i); return;} const t=grid[i]; if(!selecting && t && t.power){ enterTargeting(t.power,i); return;} startSelect(i); try{boardEl.setPointerCapture(e.pointerId); selectingPointerId=e.pointerId;}catch{}}});
  boardEl.addEventListener('pointermove',(e)=>{if(!selecting) return; const i=indexFromPoint(e.clientX,e.clientY); if(i>=0) extendTo(i);});
  boardEl.addEventListener('pointerup',()=>{if(selecting) finishSelect(); if(selectingPointerId!=null){try{boardEl.releasePointerCapture(selectingPointerId);}catch{} selectingPointerId=null;}});

  // Touch fallback (iOS Safari)
  boardEl.addEventListener('touchstart',(e)=>{
    if(!e.touches || e.touches.length===0) return; const t=e.touches[0]; e.preventDefault();
    const i=indexFromPoint(t.clientX,t.clientY); if(i>=0){ if(targeting){ applyTargeting(i); return;} const cell=grid[i]; if(!selecting && cell && cell.power){ enterTargeting(cell.power,i); return;} startSelect(i); }
  }, {passive:false});
  boardEl.addEventListener('touchmove',(e)=>{
    if(!e.touches || e.touches.length===0) return; const t=e.touches[0]; e.preventDefault(); if(!selecting) return; const i=indexFromPoint(t.clientX,t.clientY); if(i>=0) extendTo(i);
  }, {passive:false});
  boardEl.addEventListener('touchend',()=>{ if(selecting) finishSelect(); });

  // Boosters targeting (unchanged core)
  function enterTargeting(type,from){ targeting={type,from}; boardEl.classList.add('targeting'); }
  function applyTargeting(target){
    if(!targeting) return; const {type,from}=targeting; const affected=new Set();
    if(type==='breaker'){ affected.add(target); }
    else if(type==='row'){ const [r]=rc(target); for(let cc=0;cc<COLS;cc++) affected.add(idx(r,cc)); }
    else if(type==='col'){ const [,c]=rc(target); for(let rr=0;rr<ROWS;rr++) affected.add(idx(rr,c)); }
    else if(type==='rainbow'){ affected.add(target); }
    affected.forEach(j=>{ const el=boardEl.querySelector(`.tile[data-i='${j}']`); if(el) el.classList.add('explode'); });
    setTimeout(()=>{ const colorCount={yellow:0,green:0,blue:0}; affected.forEach(j=>{ const t=grid[j]; if(t && !t.obstacle && t.colorKey && colorCount[t.colorKey]!=null) colorCount[t.colorKey]++; grid[j]=null; }); if(grid[from]) grid[from].power=null; goals.yellow=Math.max(0,goals.yellow-(colorCount.yellow||0)); goals.green=Math.max(0,goals.green-(colorCount.green||0)); goals.blue=Math.max(0,goals.blue-(colorCount.blue||0)); updateGoalsUI(); const movesMap=applyGravity(); refill(); scheduleHint(); refreshDebugOverlay(); const px=cellSizePx(); Object.entries(movesMap).forEach(([to,d])=>{ const el=boardEl.querySelector(`.tile[data-i='${to}']`); if(el) el.style.setProperty('--fall',`${-d*px}px`); }); requestAnimationFrame(()=>{ Object.keys(movesMap).forEach(to=>{ const el=boardEl.querySelector(`.tile[data-i='${to}']`); if(el) el.style.setProperty('--fall','0px'); }); }); if(goalsComplete()){ toast(STRINGS[currentLang].objectivesDone); nextLevel(); return; } },260); targeting=null; boardEl.classList.remove('targeting'); }

  // Debug menu + buttons
  if(document.getElementById('debugBtn')){ debugBtn.addEventListener('click',(e)=>{e.stopPropagation(); debugMenu.classList.toggle('show');}); document.addEventListener('click',(e)=>{ if(!debugMenu.contains(e.target) && e.target!==debugBtn){ debugMenu.classList.remove('show'); }}); }
  if(debugToggleOverlayBtn){ debugToggleOverlayBtn.addEventListener('click',()=>{ debugMode=!debugMode; debugToggleOverlayBtn.classList.toggle('primary',debugMode); refreshDebugOverlay(); }); }
  if(shuffleBtn){ shuffleBtn.addEventListener('click', ()=>{ const letters=grid.map(cell=>cell && !cell.obstacle ? cell.letter : null).filter(Boolean); for(let i=letters.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [letters[i],letters[j]]=[letters[j],letters[i]]; } let k=0; grid.forEach(cell=>{ if(cell && !cell.obstacle) cell.letter=letters[k++]; }); render(); toast(STRINGS[currentLang].shuffled); scheduleHint(); refreshDebugOverlay(); }); }
  if(endTurnBtn){ endTurnBtn.addEventListener('click', ()=>{ spendMove(); if(moves===0){ toast(STRINGS[currentLang].outOfMoves); nextLevel(); } else { toast(STRINGS[currentLang].turnEnded); } }); }

  // Tutorial
  function maybeShowTutorial(){ try{ if(localStorage.getItem('lexica_tutorial_shown')) return; }catch(e){} tutorialEl.hidden=false; }
  if(closeTutorialBtn){ closeTutorialBtn.addEventListener('click', ()=>{ tutorialEl.hidden=true; try{ localStorage.setItem('lexica_tutorial_shown','1'); }catch(e){} }); }
  if(tutorialEl && tutorialEl.hasAttribute('data-backdrop')){ tutorialEl.addEventListener('click', (e)=>{ if(e.target===tutorialEl){ tutorialEl.hidden=true; try{ localStorage.setItem('lexica_tutorial_shown','1'); }catch(_){} } }); }

  // Icons from repo sprites
  function setBoosterIcons(urlBreaker, urlRow, urlCol, urlRainbow){ const root=document.documentElement; if(urlBreaker) root.style.setProperty('--img-breaker', `url(${urlBreaker})`); if(urlRow) root.style.setProperty('--img-row', `url(${urlRow})`); if(urlCol) root.style.setProperty('--img-col', `url(${urlCol})`); if(urlRainbow) root.style.setProperty('--img-rainbow', `url(${urlRainbow})`); }

  async function init(){
    moves=20; movesEl.textContent=moves;
    ensureBoardSize();
    makeEmpty(); placeInitial(); placeIceBlockers(); render(); updateGoalsUI(); applyLanguageToUI(); maybeShowTutorial();
    // load dictionaries for current language early (non-blocking for UI)
    loadDictionary(currentLang).then(()=>{ scheduleHint(); if(debugMode) refreshDebugOverlay(); });
    // No sprites: boosters use emojis now
    window.addEventListener('resize', ()=>{ ensureBoardSize(); render(); });
    // set selector value + listener
    const langSelect=document.getElementById('langSelect');
    if(langSelect){ langSelect.value=currentLang; langSelect.addEventListener('change', async ()=>{ currentLang=langSelect.value; try{ localStorage.setItem('lexica_lang', currentLang); }catch(_){ } applyLanguageToUI(); await loadDictionary(currentLang); scheduleHint(); if(debugMode) refreshDebugOverlay(); }); }
  }
  init();
})();
</script>
</body>
</html>
