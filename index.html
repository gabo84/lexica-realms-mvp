<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Lexica Realms - MVP</title>
<style>
  :root{
    --pastel1:#cfe9ff; --pastel2:#c9fff0; --pastel3:#f8f1d2; --pastel4:#e8d6ff; --pastel5:#ffe7e0;
    --blue:#77b7ff; --lilac:#c3a5ff; --shadow: rgba(0,0,0,0.12); --ink:#111;
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent;touch-action:none;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;background:linear-gradient(180deg,#f6fbff,#f9f9ff);color:var(--ink);}
  #app{width:100vw;height:100vh;max-width:1080px;margin:0 auto;display:flex;flex-direction:column;}

  header{width:100%;padding:12px 16px;display:flex;justify-content:space-between;align-items:center;background:rgba(255,255,255,.85);backdrop-filter:blur(6px);box-shadow:0 2px 10px var(--shadow);}
  .stat{display:flex;gap:10px;align-items:center;font-weight:700;}
  .pill{background:#fff;padding:8px 12px;border-radius:999px;box-shadow:0 2px 6px var(--shadow);font-weight:800;}
  #current-word{font-weight:900;letter-spacing:.5px;}

  /* Board 80% ancho (mobile first) */
  #board{width:80vw;max-width:720px;aspect-ratio:1/1;margin:10px auto;padding:10px;background:rgba(255,255,255,.7);border-radius:16px;box-shadow:0 10px 30px var(--shadow);position:relative;}
  #tiles{position:absolute; inset:0; display:grid; grid-template-columns:repeat(7,1fr); grid-template-rows:repeat(7,1fr); gap:8px;}

  /* Tiles ‚Äúplaca‚Äù sin puntos de esquina (m√°s robusto en iPhone) + desfase por columna */
  .tile{
    display:flex; align-items:center; justify-content:center;
    font-size: clamp(18px,7vw,42px); font-weight:900; color: var(--ink);
    user-select:none; position:relative;
    background: linear-gradient(135deg, #f2ddb6, #d9b67a);
    box-shadow:
      0 6px 14px rgba(0,0,0,.18),
      inset 0 2px 0 rgba(255,255,255,.7),
      inset 0 -3px 0 rgba(0,0,0,.25),
      inset 3px 0 0 rgba(255,255,255,.15),
      inset -3px 0 0 rgba(0,0,0,.08);
    border-radius: 8px;
    transition: transform 260ms cubic-bezier(0.22, 1, 0.36, 1), box-shadow 140ms ease, filter 180ms ease; will-change: transform;
    --ty: 0px; --sc: 1;
    transform: translateY(calc(var(--ty) + var(--fall, 0px))) scale(var(--sc));
  }
  .tile.selected{
    --sc: .95;
    box-shadow:
      0 0 0 3px #0aa inset,
      0 0 0 3px rgba(0,0,0,.2),
      0 10px 22px rgba(0,0,0,.22),
      inset 0 2px 0 rgba(255,255,255,.8),
      inset 0 -4px 0 rgba(0,0,0,.3);
  }
  .tile.glow{ animation: glow 800ms ease-out; }
  @keyframes glow{ 0%{ filter: drop-shadow(0 0 0 rgba(255,255,255,0)); } 50%{ filter: drop-shadow(0 0 12px rgba(255,255,255,1)); } 100%{ filter: drop-shadow(0 0 0 rgba(255,255,255,0)); } }

  /* explosi√≥n + ca√≠da */
  .tile.explode{ animation: explode .22s ease-out forwards; }
  @keyframes explode{ 0%{ transform: translateY(calc(var(--ty) + var(--fall, 0px))) scale(1); opacity:1; } 100%{ transform: translateY(calc(var(--ty) - 12px)) scale(.6); opacity:0; filter: blur(1px); } }
  .tile.fall{ animation: fall .18s ease-out; }
  @keyframes fall{ 0%{ transform: translateY(calc(var(--ty) - 14px)) scale(1); } 100%{ transform: translateY(calc(var(--ty) + var(--fall, 0px))) scale(1); } }

  .tile.obstacle-stone{background:#bfc4cc;color:transparent;}
  .tile.obstacle-frozen{background:linear-gradient(135deg,#c9f2ff,#b6e0ff);}
  .tile .badge{position:absolute;bottom:6px;right:6px;font-size:12px;font-weight:800;background:#111;color:#fff;padding:2px 6px;border-radius:999px;letter-spacing:.2px;opacity:.9;}
  .tile .ord{position:absolute; top:6px; left:6px; width:20px; height:20px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:12px; font-weight:800; background:#111; color:#fff; box-shadow:0 1px 3px rgba(0,0,0,.2);}

  /* Hint + Debug (solo clases, sin l√≠neas) */
  .tile.hint{ box-shadow: 0 0 0 3px #17a2b8 inset, 0 6px 18px rgba(23,162,184,.35); }
  .tile.debug{ outline:3px dashed rgba(255,0,110,.6); outline-offset:-3px; }

  /* Booster icons */
  .tile.breaker::after{content:"üî®";position:absolute;top:6px;left:6px;font-size:16px;opacity:.95;}     /* 5 letras */
  .tile.col::after{content:"‚¨áÔ∏è";position:absolute;top:6px;left:6px;font-size:16px;opacity:.95;}         /* 4 letras */
  .tile.rainbow::after{content:"üåà";position:absolute;top:6px;left:6px;font-size:16px;opacity:.95;}     /* 6+ letras */
  .tile.rainbow{background:conic-gradient(from 0deg,#f9c,#9cf,#9fc,#fc9,#f9c);}

  /* Targeting mode */
  #board.targeting .tile{ cursor: crosshair; }

  #bottom{width:100%;padding:12px 16px 18px;display:flex;gap:10px;align-items:center;justify-content:space-between;background:rgba(255,255,255,.88);backdrop-filter:blur(6px);box-shadow:0 -2px 10px var(--shadow);}
  .btn{border:none;padding:12px 16px;border-radius:12px;font-weight:800;background:#fff;box-shadow:0 3px 10px var(--shadow);}
  .btn.primary{background:var(--blue);color:#fff;} .btn.warn{background:var(--lilac);color:#111;}

  #toast{position:fixed;top:10px;left:50%;transform:translateX(-50%);background:#111;color:#fff;padding:10px 14px;border-radius:10px;box-shadow:0 8px 20px rgba(0,0,0,.2);opacity:0;pointer-events:none;transition:opacity .2s ease;z-index:9;}
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="stat">
      <span class="pill">Level <span id="level">1</span></span>
      <span class="pill">Moves <span id="moves">20</span></span>
      <span class="pill">Score <span id="score">0</span>/<span id="target">500</span></span>
    </div>
    <div class="pill" id="current-word">WORD</div>
  </header>

  <div id="board" aria-label="Game board">
    <!-- Sin SVG, s√≥lo las fichas -->
    <div id="tiles"></div>
  </div>

  <div id="bottom">
    <div style="display:flex;gap:8px;align-items:center;">
      <button class="btn warn" id="shuffleBtn">Shuffle</button>
      <button class="btn" id="endTurnBtn">End Turn</button>
      <button class="btn" id="debugBtn" title="Toggle debug">Debug</button>
    </div>
    <div style="display:flex;gap:8px;align-items:center;">
      <span class="pill" id="powerHint">Press, drag across letters (diagonals ok), release to submit</span>
    </div>
  </div>
</div>
<div id="toast"></div>

<script>
(function(){
  const size = 7;
  const vowels = "AEIOU";
  const lettersBag = [..."EEEEEEEEEEEEAAAAAAAIIIIIIIOOOOOONNNNNNRRRRRRTTTTTTLLLLSSSSUUUUDDDDGGGBBCCMMPPFFHHVVWWYKJXQZ"];

  /* ==== DICCIONARIO BASE (local, reducido) ==== */
  const wordList = ["ABLE","ABOUT","ACTION","AFTER","AGAIN","ALIGN","ALIVE","ALONG","ALWAYS","APPLE","ARROW","ARRAY","AUDIO","AWARE","BALANCE","BASIC","BEACH","BEFORE","BEGIN","BELONG","BLACK","BLOCK","BLOOM","BOARD","BOOST","BRAIN","BRAVE","BREAK","BRIDGE","BRIGHT","BUILD","BURN","CABLE","CANDY","CANVAS","CHAIN","CHAIR","CHARGE","CHECK","CIRCLE","CLASS","CLEAR","CLICK","CLOCK","CLOSE","CLOUD","COACH","CODE","COIN","COLOR","COMMON","COUNT","COURT","COVER","CRACK","CRAFT","CRISP","CROSS","CROWN","CRUSH","CRYSTAL","DAILY","DANCE","DARK","DATA","DEAL","DEEP","DESIGN","DIAMOND","DIGIT","DRAGON","DREAM","DRINK","DRIVE","DROP","EARLY","EARTH","EAST","EASY","ECHO","EDIT","ELITE","EMPTY","ENERGY","ENJOY","ENTER","EQUAL","ERROR","ESCAPE","EVENT","EXACT","EXPAND","EXTRA","FACE","FAIR","FALL","FAMILY","FAST","FIELD","FIGHT","FINAL","FIND","FIRE","FIRST","FISH","FLAME","FLASH","FLAT","FLIGHT","FLOAT","FLOOR","FLOWER","FOCUS","FOLD","FOLLOW","FORCE","FOREST","FORGE","FRAME","FREE","FRESH","FRIEND","FROZEN","FRUIT","FUTURE","GAIN","GAME","GATE","GEM","GHOST","GIFT","GLOW","GOAL","GOLD","GRASS","GREAT","GREEN","GRID","GROW","GUARD","GUIDE","HABIT","HALL","HAND","HARD","HEART","HELLO","HELP","HERO","HIGH","HILL","HINT","HOLD","HOME","HONOR","HOPE","HORSE","HOUR","HOUSE","HUMAN","IDEA","IMAGE","IMPACT","INDEX","INSIDE","INSPIRE","IRON","ISLAND","ITEM","IVORY","JAZZ","JOB","JOIN","JUMP","KEEP","KEY","KIND","KING","KNIFE","KNOW","LABEL","LAKE","LAMP","LAND","LASER","LAUGH","LEAD","LEARN","LEMON","LETTER","LEVEL","LIGHT","LIKE","LINE","LINK","LION","LIST","LOCAL","LOCK","LOGIC","LONG","LOOK","LOOP","LOUD","LOVE","LUCK","LUNCH","MACHINE","MAJOR","MAKE","MAP","MARK","MARKET","MASTER","MATCH","MATH","MEAL","MEET","MEMORY","METAL","METHOD","MIDDLE","MIGHT","MIND","MODEL","MONEY","MONTH","MOON","MORNING","MOTION","MOUSE","MOVE","MOVIE","MUSIC","NAME","NATION","NEAR","NEED","NEVER","NIGHT","NORTH","NOTE","NOVEL","NURSE","OBJECT","OCEAN","OFFICE","OPEN","ORANGE","ORDER","OTHER","OUTER","OWNER","OXYGEN","PACE","PACK","PAGE","PAINT","PALACE","PAPER","PARK","PART","PARTY","PAST","PATH","PEACE","PEOPLE","PHONE","PHOTO","PIANO","PICK","PIECE","PILOT","PLACE","PLAN","PLANE","PLANT","PLATE","PLAY","POINT","POWER","PRICE","PRIDE","PRIME","PRINT","PRIZE","PROBLEM","PROCESS","PRODUCT","PROFILE","PROGRAM","PROJECT","PROOF","PUBLIC","PULL","PURE","PURPLE","QUEEN","QUICK","QUIET","QUOTE","RACE","RADAR","RAIN","RAISE","RANGE","RAPID","RARE","RATE","REACH","READ","READY","REAL","REASON","RECORD","REFRESH","REGION","RELAX","REMAIN","REMOVE","REPAIR","REPEAT","REPORT","RESCUE","RESPECT","RESULT","RETURN","REVIEW","REWARD","RICH","RIDE","RIGHT","RING","RISE","RIVER","ROAD","ROCK","ROLE","ROLL","ROOF","ROOM","ROPE","ROSE","ROUND","ROUTE","ROYAL","RULE","RUN","SAFE","SALT","SAME","SAND","SAVE","SCALE","SCAN","SCENE","SCHOOL","SCIENCE","SCORE","SCREEN","SEA","SEASON","SEAT","SEED","SEE","SEEK","SELECT","SELL","SEND","SENSE","SERIES","SERVER","SET","SEVEN","SHADOW","SHAKE","SHAPE","SHARE","SHIFT","SHINE","SHIP","SHOCK","SHOP","SHORT","SHOT","SHOW","SIDE","SIGHT","SIGN","SIMPLE","SINCE","SISTER","SKILL","SKY","SLEEP","SLIDE","SMALL","SMART","SMILE","SMOKE","SNAKE","SNOW","SOAP","SOCIAL","SOFT","SOLAR","SOLID","SONG","SOON","SOUL","SOUND","SOURCE","SOUTH","SPACE","SPEAK","SPECIAL","SPEED","SPELL","SPEND","SPIRIT","SPORT","SPOT","SPRING","SQUARE","STABLE","STAGE","STAMP","STAR","START","STATE","STATUS","STAY","STEEL","STEP","STICK","STILL","STOCK","STONE","STORY","STREAM","STREET","STRONG","STUDY","STYLE","SUMMER","SUN","SUPER","SUPPLY","SURE","SURPRISE","SURVEY","SWEET","SWIM","SWORD","SYSTEM","TABLE","TAKE","TALENT","TALK","TARGET","TEAM","TECH","TEETH","TELL","TERM","TEST","TEXT","THANK","THEME","THEORY","THERE","THING","THINK","THREE","THROW","TICKET","TIME","TITLE","TODAY","TOGETHER","TONE","TOOL","TOUCH","TOWER","TOWN","TRACK","TRADE","TRAIL","TRAIN","TRAVEL","TREAT","TREE","TREND","TRIAL","TRICK","TRIP","TROPHY","TRUCK","TRUE","TRUST","TYPE","UNDER","UNION","UNIQUE","UNKNOWN","UNTIL","UPDATE","URBAN","USER","USUAL","VALUE","VERY","VIDEO","VIEW","VILLAGE","VISION","VISIT","VOICE","VOLUME","WAIT","WALK","WALL","WANT","WARM","WASH","WASTE","WATCH","WATER","WAVE","WAY","WEAR","WEATHER","WEEK","WELCOME","WEST","WHALE","WHAT","WHEEL","WHEN","WHERE","WHITE","WHO","WHOLE","WIDE","WILD","WILL","WIND","WINDOW","WINE","WING","WINNER","WINTER","WIRE","WISE","WISH","WOMAN","WONDER","WOOD","WORD","WORK","WORLD","WORTH","WRITE","WRONG","YARD","YEAR","YELLOW","YOUNG","YOUTH","ZEBRA","ZERO","ZOO"];
  const dictionary = new Set(wordList.map(w=>w.toUpperCase()));

  /* prefijos para podar DFS (hint/debug) */
  const prefixes = new Set(); for(const w of wordList){ const u=w.toUpperCase(); for(let i=1;i<=u.length;i++) prefixes.add(u.slice(0,i)); }

  const boardEl = document.getElementById("board");
  const levelEl = document.getElementById("level");
  const scoreEl = document.getElementById("score");
  const targetEl = document.getElementById("target");
  const movesEl = document.getElementById("moves");
  const wordEl = document.getElementById("current-word");
  const toastEl = document.getElementById("toast");
  const shuffleBtn = document.getElementById("shuffleBtn");
  const endTurnBtn = document.getElementById("endTurnBtn");
  const debugBtn = document.getElementById("debugBtn");

  let level=1, score=0, target=500, moves=20;
  let grid=[]; let selection=[]; let selecting=false;
  let hintTimer=null; const HINT_DELAY_MS=5000; let currentHint=null;
  let debugMode=false; let targeting=null;
  let selectingPointerId=null;
  let submitting=false;

  function cellSizePx(){ const rect=boardEl.getBoundingClientRect(); return rect.height/size; }
  function columnOffsetPx(){
    // always half a tile height, rounded to whole px
    return Math.round(cellSizePx()/2);
  }
  function animateDestruction(indices){ (Array.isArray(indices)?indices:Array.from(indices)).forEach(i=>{ const el=boardEl.querySelector(`.tile[data-i='${i}']`); if(el) el.classList.add('explode'); }); }
  function randLetter(){ const pick=lettersBag[Math.floor(Math.random()*lettersBag.length)]; return Math.random()<0.12?vowels[Math.floor(Math.random()*vowels.length)]:pick; }
  function randomPastelIndex(){ return (Math.floor(Math.random()*5)+1).toString(); }
  function makeEmpty(){ grid=Array.from({length:size*size},()=>null); }
  function idx(r,c){ return r*size+c; } function rc(i){ return [Math.floor(i/size),i%size]; } function inBounds(r,c){ return r>=0&&c>=0&&r<size&&c<size; }

  function placeInitial(){
    for(let r=0;r<size;r++) for(let c=0;c<size;c++) grid[idx(r,c)]=newTile();
    if(level>=6) sprinkleObstacles("stone", Math.min(6, Math.floor(level/2)));
    if(level>=12) sprinkleObstacles("frozen", Math.min(7, Math.floor(level/2)));
  }
  function sprinkleObstacles(type,count){
    let placed=0;
    while(placed<count){
      const i=Math.floor(Math.random()*grid.length), t=grid[i]; if(!t) continue;
      if(type==="stone" && !t.obstacle && !t.frozen){ t.obstacle="stone"; t.letter=""; t.bg=0; placed++; }
      else if(type==="frozen" && !t.obstacle && !t.frozen){ t.frozen=true; placed++; }
    }
  }
  function newTile(){ return {letter:randLetter(), bg:randomPastelIndex(), obstacle:null, frozen:false, power:null}; }

  function render(){
    const tilesEl=document.getElementById("tiles"); tilesEl.innerHTML="";
    grid.forEach((cell,i)=>{
      const div=document.createElement("div"); div.className="tile"; div.dataset.i=i;
      const [r,c]=rc(i); div.style.setProperty('--ty', (c%2? columnOffsetPx()+"px" : '0px')); // offset = 1/2 pieza
      if(cell){
        if(cell.obstacle==="stone"){ div.classList.add("obstacle-stone"); div.textContent=""; }
        else{
          div.textContent=cell.letter;
          if(cell.frozen) div.classList.add("obstacle-frozen");
          if(cell.power){
            div.classList.add(cell.power);
            const b=document.createElement("span"); b.className="badge";
            b.textContent=cell.power==="rainbow"?"üåà":(cell.power==="breaker"?"üî®":"‚¨áÔ∏è");
            div.appendChild(b);
          }
        }
      } else { div.style.visibility="hidden"; }
      tilesEl.appendChild(div);
    });
  }

  function isAdjacent(a,b){ const [ar,ac]=rc(a),[br,bc]=rc(b); return Math.max(Math.abs(ar-br),Math.abs(ac-bc))===1; }

  /* ==== selecci√≥n por ARRASTRE (Pointer Events) ==== */
  function indexFromClientPoint(x,y){
    const el = document.elementFromPoint(x,y);
    return Number(el?.dataset?.i ?? -1);
  }

  function startSelect(i){
    clearTimeout(hintTimer); clearHint();
    const t=grid[i]; if(!t || t.obstacle==='stone' || submitting) return;
    selecting=true; selection=[i]; updateSelectionClasses(); updateWordDisplay();
  }

  function extendTo(i){
    if(!selecting) return;
    if(i<0) return;
    const t=grid[i]; if(!t || t.obstacle==='stone') return;
    const last = selection[selection.length-1];
    if(i===last) return;

    // backtrack 1
    if(selection.length>=2 && i===selection[selection.length-2]){
      selection.pop(); updateSelectionClasses(); updateWordDisplay(); return;
    }
    // recortar a cualquier punto del camino
    const pos = selection.indexOf(i);
    if(pos !== -1){
      selection = selection.slice(0, pos+1);
      updateSelectionClasses(); updateWordDisplay(); return;
    }

    // extender solo si es adyacente
    if(isAdjacent(last,i)){
      selection.push(i);
      updateSelectionClasses(); updateWordDisplay(); return;
    }
  }

  function finishSelect(){
    if(!selecting) return;
    selecting = false;

    // si termina en la primera (y hay m√°s de 1), cancelar intento
    if(selection.length>1 && selection[selection.length-1] === selection[0]){
      clearSelection(); scheduleHint(); return;
    }
    if(selection.length<3){ clearSelection(); scheduleHint(); return; }

    endSelect(); // async
  }

  /* ==== Validaci√≥n de palabra (local + online con cach√©) ==== */
  const onlineCache = new Map();
  async function onlineValid(u){
    const lc = u.toLowerCase();
    if(onlineCache.has(lc)) return onlineCache.get(lc);
    const controller = new AbortController();
    const t = setTimeout(()=>controller.abort(), 1300);
    try{
      const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(lc)}`, {signal: controller.signal});
      clearTimeout(t);
      let ok=false;
      if(res.ok){
        const js = await res.json();
        ok = Array.isArray(js) && js.length>0;
      }
      onlineCache.set(lc, ok);
      return ok;
    }catch(e){
      clearTimeout(t);
      onlineCache.set(lc, false);
      return false;
    }
  }
  async function isValidWordAsync(word){
    if(!word || word.length<3) return false;
    const u=word.toUpperCase();
    if(dictionary.has(u)) return true;
    return await onlineValid(u);
  }

  /* ==== Utilidades de selecci√≥n ==== */
  function getCurrentWord(){ return selection.map(i=>grid[i]?.letter||"").join(""); }
  function drawPath(){ /* sin flechas */ }
  function updateOrderBadges(){
    document.querySelectorAll('.tile .ord').forEach(n=>n.remove());
    selection.forEach((i, idx)=>{
      const el=boardEl.querySelector(`.tile[data-i='${i}']`); if(!el) return;
      const b=document.createElement('span'); b.className='ord'; b.textContent=(idx+1).toString(); el.appendChild(b);
    });
  }
  function updateSelectionClasses(){
    document.querySelectorAll(".tile").forEach(t=>t.classList.remove("selected"));
    selection.forEach(i=>{ const el=boardEl.querySelector(`.tile[data-i='${i}']`); if(el) el.classList.add("selected"); });
    drawPath(); updateOrderBadges();
  }
  function updateWordDisplay(){ wordEl.textContent=getCurrentWord()||"WORD"; }
  function clearSelection(){
    selection=[]; updateSelectionClasses(); updateWordDisplay();
    document.querySelectorAll('.tile .ord').forEach(n=>n.remove());
  }

  async function endSelect(){
    if(submitting) return;
    submitting = true;
    const word = getCurrentWord();
    const valid = await isValidWordAsync(word);
    if(valid){ resolveWord(word); }
    else { shakeBoard(); clearSelection(); scheduleHint(); }
    submitting = false;
  }

  function isValidWord(word){ return dictionary.has((word||"").toUpperCase()); } // legacy (no usada)

  /* ==== Score / niveles ==== */
  function addScore(n){ score+=n; scoreEl.textContent=score; }
  function spendMove(){ moves=Math.max(0,moves-1); movesEl.textContent=moves; }
  function nextLevel(){ level++; levelEl.textContent=level; score=0; scoreEl.textContent=score; target=computeTarget(level); targetEl.textContent=target; moves=20; movesEl.textContent=moves; makeEmpty(); placeInitial(); render(); refreshDebugOverlay(); toast("Level up"); }
  function computeTarget(lv){ if(lv<=5) return 500; if(lv<=10) return 700; if(lv<=15) return 900; return 1200; }

  function resolveWord(word){
    const len=selection.length; let points=10*len; let newPower=null;
    // NUEVA l√≥gica de boosters
    if(len>=6) newPower="rainbow";        // comod√≠n
    else if(len===5) newPower="breaker";  // rome una pieza
    else if(len===4) newPower="col";      // rompe columna

    const toRemove=new Set(selection);
    selection.forEach(i=>{ const t=grid[i]; if(t && t.frozen){ t.frozen=false; toRemove.delete(i);} });

    const stonesToRemove=new Set();
    toRemove.forEach(i=>{ const [r,c]=rc(i); for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0) continue; const nr=r+dr,nc=c+dc; if(inBounds(nr,nc)){ const j=idx(nr,nc); if(grid[j] && grid[j].obstacle==="stone") stonesToRemove.add(j); } } });

    toRemove.forEach(i=>grid[i]=null); stonesToRemove.forEach(i=>grid[i]=null);

    if(newPower){
      const last=selection[selection.length-1]; let tIdx=last; if(grid[tIdx]!==null) tIdx=Array.from(toRemove)[0]??last;
      if(tIdx!=null) grid[tIdx]={letter:newPower==="rainbow"?"*":randLetter(), bg:randomPastelIndex(), obstacle:null, frozen:false, power:newPower};
      points+=30; document.getElementById("powerHint").textContent="You created a power up";
    }

    const movesMap=applyGravity(); refill(); scheduleHint(); refreshDebugOverlay();

    const px=cellSizePx();
    Object.entries(movesMap).forEach(([to,d])=>{ const el=boardEl.querySelector(`.tile[data-i='${to}']`); if(el) el.style.setProperty('--fall',`${-d*px}px`); });
    requestAnimationFrame(()=>{ Object.keys(movesMap).forEach(to=>{ const el=boardEl.querySelector(`.tile[data-i='${to}']`); if(el) el.style.setProperty('--fall','0px'); }); });

    flashGlow(selection); clearSelection(); addScore(points); spendMove();
    if(score>=target){ toast("Target reached"); nextLevel(); return; }
    if(moves===0){ toast("Out of moves"); nextLevel(); }
  }

  function applyGravity(){
    const moves={};
    for(let c=0;c<size;c++){
      let write=size-1;
      for(let r=size-1;r>=0;r--){
        const i=idx(r,c), cell=grid[i];
        if(cell){
          if(cell.obstacle==="stone"){ write=r-1; continue; }
          if(write!==r){ const wi=idx(write,c); grid[wi]=cell; grid[i]=null; moves[wi]=(moves[wi]||0)+(write-r); }
          write--;
        }
      }
    }
    return moves;
  }
  function refill(){ for(let c=0;c<size;c++) for(let r=0;r<size;r++){ const i=idx(r,c); if(grid[i]===null) grid[i]=newTile(); } render(); }

  function flashGlow(indexes){ indexes.forEach(i=>{ const el=boardEl.querySelector(`.tile[data-i='${i}']`); if(el){ el.classList.add("glow"); setTimeout(()=>el.classList.remove("glow"),900); } }); }
  function shakeBoard(){ boardEl.animate([{transform:"translateX(0)"},{transform:"translateX(-8px)"},{transform:"translateX(8px)"},{transform:"translateX(0)"}],{duration:220}); toast("Not a valid word"); }
  function toast(msg){ toastEl.textContent=msg; toastEl.style.opacity=1; clearTimeout(toastEl._t); toastEl._t=setTimeout(()=>toastEl.style.opacity=0,1200); }

  /* ==== Boosters (targeting) ==== */
  function enterTargeting(type,from){ targeting={type,from}; boardEl.classList.add('targeting'); toast(type==='breaker'?'Choose a tile to break':(type==='col'?'Choose any tile in the column':'Choose where to use wildcard')); }
  function applyTargeting(target){
    if(!targeting) return;
    const {type,from}=targeting; const affected=new Set();
    if(type==='breaker'){ affected.add(target); }
    else if(type==='col'){ const [,c]=rc(target); for(let rr=0;rr<size;rr++) affected.add(idx(rr,c)); }
    else if(type==='rainbow'){ /* comod√≠n se usa dentro de palabra; aqu√≠ lo tratamos como breaker por simplicidad */ affected.add(target); }
    animateDestruction(affected);
    setTimeout(()=>{ affected.forEach(j=>grid[j]=null); if(grid[from]) grid[from].power=null;
      const movesMap=applyGravity(); refill(); scheduleHint(); refreshDebugOverlay();
      const px=cellSizePx(); Object.entries(movesMap).forEach(([to,d])=>{ const el=boardEl.querySelector(`.tile[data-i='${to}']`); if(el) el.style.setProperty('--fall',`${-d*px}px`); });
      requestAnimationFrame(()=>{ Object.keys(movesMap).forEach(to=>{ const el=boardEl.querySelector(`.tile[data-i='${to}']`); if(el) el.style.setProperty('--fall','0px'); }); });
    },260);
    targeting=null; boardEl.classList.remove('targeting');
  }

  /* ==== Eventos Pointer ==== */
  boardEl.addEventListener('pointerdown', (e)=>{
    const i = indexFromClientPoint(e.clientX, e.clientY);
    if(i<0) return;
    const t = grid[i];
    if(targeting){ applyTargeting(i); return; }
    if(!selecting && t && t.power && (t.power==='breaker'||t.power==='col'||t.power==='rainbow')){ enterTargeting(t.power, i); return; }
    startSelect(i);
    try{ boardEl.setPointerCapture(e.pointerId); selectingPointerId = e.pointerId; }catch{}
  });

  boardEl.addEventListener('pointermove', (e)=>{
    if(!selecting) return;
    const i = indexFromClientPoint(e.clientX, e.clientY);
    if(i>=0) extendTo(i);
  });

  boardEl.addEventListener('pointerup', (e)=>{
    if(selecting) finishSelect();
    if(selectingPointerId!=null){ try{ boardEl.releasePointerCapture(selectingPointerId); }catch{} selectingPointerId=null; }
  });

  /* ==== Hint ==== */
  function clearHint(){
    currentHint=null;
    document.querySelectorAll('.tile.hint').forEach(el=>el.classList.remove('hint'));
  }
  function scheduleHint(){ clearTimeout(hintTimer); hintTimer=setTimeout(()=>{ showAnyHint(); }, HINT_DELAY_MS); }
  function showHintPath(path){ path.forEach(i=>{ const el=boardEl.querySelector(`.tile[data-i='${i}']`); if(el) el.classList.add('hint'); }); }
  function showAnyHint(){
    clearHint();
    const visited=new Array(size*size).fill(false); const maxLen=6; let found=null;
    function dfs(path){
      if(found) return;
      const word=path.map(i=>grid[i]?.letter||'').join('').toUpperCase();
      if(!prefixes.has(word)) return;
      if(word.length>=3 && dictionary.has(word)){ found=path.slice(); return; }
      if(path.length===maxLen) return;
      const last=path[path.length-1]; const [r,c]=rc(last);
      for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
        if(dr===0&&dc===0) continue;
        const nr=r+dr,nc=c+dc; if(!inBounds(nr,nc)) continue;
        const j=idx(nr,nc); if(visited[j]) continue;
        const cell=grid[j]; if(!cell || cell.obstacle==='stone') continue;
        visited[j]=true; path.push(j); dfs(path); path.pop(); visited[j]=false; if(found) return;
      }
    }
    for(let i=0;i<size*size && !found;i++){ const cell=grid[i]; if(!cell || cell.obstacle==='stone') continue; visited[i]=true; dfs([i]); visited[i]=false; }
    if(found){ currentHint=found; showHintPath(found); }
  }

  /* ==== Debug ==== */
  function clearDebug(){ document.querySelectorAll('.tile.debug').forEach(el=>el.classList.remove('debug')); }
  function drawDebugPaths(list){
    clearDebug();
    const maxDraw=Math.min(list.length,80);
    for(let n=0;n<maxDraw;n++){ const {path}=list[n]; path.forEach(i=>{ const el=boardEl.querySelector(`.tile[data-i='${i}']`); if(el) el.classList.add('debug'); }); }
  }
  function findAllWordsOnBoard(){
    const results=[]; const visited=new Array(size*size).fill(false); const maxLen=7;
    function dfs(path){
      const word=path.map(i=>grid[i]?.letter||'').join('').toUpperCase(); if(!prefixes.has(word)) return;
      if(word.length>=3 && dictionary.has(word)){ results.push({word, path:path.slice()}); if(results.length>200) return; }
      if(path.length===maxLen) return;
      const last=path[path.length-1]; const [r,c]=rc(last);
      for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
        if(dr===0&&dc===0) continue;
        const nr=r+dr,nc=c+dc; if(!inBounds(nr,nc)) continue;
        const j=idx(nr,nc); if(visited[j]) continue;
        const cell=grid[j]; if(!cell || cell.obstacle==='stone') continue;
        visited[j]=true; path.push(j); dfs(path); path.pop(); visited[j]=false; if(results.length>200) return;
      }
    }
    for(let i=0;i<size*size;i++){ const cell=grid[i]; if(!cell || cell.obstacle==='stone') continue; visited[i]=true; dfs([i]); visited[i]=false; if(results.length>200) break; }
    return results;
  }
  function refreshDebugOverlay(){ if(!debugMode){ clearDebug(); return; } const list=findAllWordsOnBoard(); drawDebugPaths(list); toast(list.length+' words'); }

  /* ==== Botones ==== */
  shuffleBtn.addEventListener("click", ()=>{
    const letters=grid.map(cell=>cell && !cell.obstacle ? cell.letter : null).filter(Boolean);
    for(let i=letters.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [letters[i],letters[j]]=[letters[j],letters[i]]; }
    let k=0; grid.forEach(cell=>{ if(cell && !cell.obstacle) cell.letter=letters[k++]; });
    render(); toast("Shuffled"); scheduleHint(); refreshDebugOverlay();
  });
  endTurnBtn.addEventListener("click", ()=>{ spendMove(); if(moves===0){ toast("Out of moves"); nextLevel(); } else { toast("Turn ended"); } });
  if(debugBtn) debugBtn.addEventListener('click', ()=>{ debugMode=!debugMode; debugBtn.classList.toggle('primary',debugMode); refreshDebugOverlay(); });

  /* ==== Init ==== */
  function init(){ level=1; score=0; target=computeTarget(level); moves=20;
    levelEl.textContent=level; scoreEl.textContent=score; targetEl.textContent=target; movesEl.textContent=moves;
    makeEmpty(); placeInitial(); render(); scheduleHint();
  }
  init();

  window.addEventListener('resize', ()=>{
    // re-render to refresh dynamic column offset
    render();
  });
})();
</script>

<footer style="max-width:1080px;margin:16px auto 28px;padding:12px 16px;color:#333;font-size:14px;line-height:1.5;">
  <strong>Boosters (actualizados):</strong>
  <ul style="margin:8px 0 0 18px; padding:0;">
    <li><strong>4 letras ‚Üí ‚¨áÔ∏è Column breaker:</strong> toca el booster y luego cualquier ficha de la columna a romper (toda la columna desaparece).</li>
    <li><strong>5 letras ‚Üí üî® Block breaker:</strong> toca el booster y luego una ficha para <em>romper solo esa pieza</em>.</li>
    <li><strong>6+ letras ‚Üí üåà Rainbow (comod√≠n):</strong> √∫salo dentro de una palabra; puede reemplazar <em>cualquier letra</em>. (En targeting directo act√∫a como romper 1 pieza).</li>
  </ul>
</footer>
</body>
</html>
